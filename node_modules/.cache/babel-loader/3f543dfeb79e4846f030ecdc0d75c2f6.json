{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst xoshiro_1 = __importDefault(require(\"./xoshiro\"));\n\nconst randomSampler = require('@apocentre/alias-sampling');\n\nconst chooseDegree = (seqLenth, rng) => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n  return degreeChooser.next() + 1;\n};\n\nexports.chooseDegree = chooseDegree;\n\nconst shuffle = (items, rng) => {\n  let remaining = [...items];\n  let result = [];\n\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index]; // remaining.erase(remaining.begin() + index);\n\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n\n  return result;\n};\n\nexports.shuffle = shuffle;\n\nconst chooseFragments = (seqNum, seqLength, checksum) => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([utils_1.intToBytes(seqNum), utils_1.intToBytes(checksum)]);\n    const rng = new xoshiro_1.default(seed);\n    const degree = exports.chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = exports.shuffle(indexes, rng);\n    return shuffledIndexes.slice(0, degree);\n  }\n};\n\nexports.chooseFragments = chooseFragments;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA,MAAMA,aAAa,GAAGC,OAAO,CAAC,2BAAD,CAA7B;;AAEO,MAAMC,YAAY,GAAG,CAACC,QAAD,EAAmBC,GAAnB,KAA2C;AACrE,QAAMC,mBAAmB,GAAG,CAAC,GAAG,IAAIC,KAAJ,CAAUH,QAAV,CAAJ,EAAyBI,GAAzB,CAA6B,CAACC,CAAD,EAAIC,KAAJ,KAAc,KAAKA,KAAK,GAAG,CAAb,CAA3C,CAA5B;AACA,QAAMC,aAAa,GAAGV,aAAa,CAACK,mBAAD,EAAsB,IAAtB,EAA4BD,GAAG,CAACO,UAAhC,CAAnC;AAEA,SAAOD,aAAa,CAACE,IAAd,KAAuB,CAA9B;AACD,CALM;;AAAMC,uBAAYX,YAAZ;;AAQN,MAAMY,OAAO,GAAG,CAACC,KAAD,EAAeX,GAAf,KAAsC;AAC3D,MAAIY,SAAS,GAAG,CAAC,GAAGD,KAAJ,CAAhB;AACA,MAAIE,MAAM,GAAG,EAAb;;AAEA,SAAOD,SAAS,CAACE,MAAV,GAAmB,CAA1B,EAA6B;AAC3B,QAAIT,KAAK,GAAGL,GAAG,CAACe,OAAJ,CAAY,CAAZ,EAAeH,SAAS,CAACE,MAAV,GAAmB,CAAlC,CAAZ;AACA,QAAIE,IAAI,GAAGJ,SAAS,CAACP,KAAD,CAApB,CAF2B,CAG3B;;AACAO,aAAS,CAACK,MAAV,CAAiBZ,KAAjB,EAAwB,CAAxB;AACAQ,UAAM,CAACK,IAAP,CAAYF,IAAZ;AACD;;AAED,SAAOH,MAAP;AACD,CAbM;;AAAMJ,kBAAOC,OAAP;;AAgBN,MAAMS,eAAe,GAAG,CAACC,MAAD,EAAiBC,SAAjB,EAAoCC,QAApC,KAAkE;AAC/F;AACA;AACA;AACA,MAAIF,MAAM,IAAIC,SAAd,EAAyB;AACvB,WAAO,CAACD,MAAM,GAAG,CAAV,CAAP;AACD,GAFD,MAEO;AACL,UAAMG,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,CAACC,mBAAWN,MAAX,CAAD,EAAqBM,mBAAWJ,QAAX,CAArB,CAAd,CAAb;AACA,UAAMtB,GAAG,GAAG,IAAI2B,iBAAJ,CAAYJ,IAAZ,CAAZ;AACA,UAAMK,MAAM,GAAGnB,qBAAaY,SAAb,EAAwBrB,GAAxB,CAAf;AACA,UAAM6B,OAAO,GAAG,CAAC,GAAG,IAAI3B,KAAJ,CAAUmB,SAAV,CAAJ,EAA0BlB,GAA1B,CAA8B,CAACC,CAAD,EAAIC,KAAJ,KAAcA,KAA5C,CAAhB;AACA,UAAMyB,eAAe,GAAGrB,gBAAQoB,OAAR,EAAiB7B,GAAjB,CAAxB;AAEA,WAAO8B,eAAe,CAACC,KAAhB,CAAsB,CAAtB,EAAyBH,MAAzB,CAAP;AACD;AACF,CAfM;;AAAMnB,0BAAeU,eAAf","names":["randomSampler","require","chooseDegree","seqLenth","rng","degreeProbabilities","Array","map","_","index","degreeChooser","nextDouble","next","exports","shuffle","items","remaining","result","length","nextInt","item","splice","push","chooseFragments","seqNum","seqLength","checksum","seed","Buffer","concat","utils_1","xoshiro_1","degree","indexes","shuffledIndexes","slice"],"sourceRoot":"","sources":["../src/fountainUtils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}