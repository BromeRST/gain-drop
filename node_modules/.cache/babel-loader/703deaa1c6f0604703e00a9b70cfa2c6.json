{"ast":null,"code":"'use strict';\n/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bigInt = require('big-integer');\n\nconst base32 = require('./base32');\n\nconst convertBits_1 = require('./convertBits');\n\nconst validation = require('./validation');\n\nconst validate = validation.validate;\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md}\n * @module cashaddr\n */\n\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n *\n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\n\nfunction encode(prefix, type, hash) {\n  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  const versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  const payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n  const checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n  const payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n  return prefix + ':' + base32.encode(payload);\n}\n\nexports.encode = encode;\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n *\n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\n\nfunction decode(address) {\n  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n  const pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  const prefix = pieces[0];\n  const payload = base32.decode(pieces[1]);\n  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n  const payloadData = fromUint5Array(payload.subarray(0, -8));\n  const versionByte = payloadData[0];\n  const hash = payloadData.subarray(1);\n  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n  const type = getType(versionByte);\n  return {\n    prefix,\n    type,\n    hash\n  };\n}\n\nexports.decode = decode;\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\n\nexports.ValidationError = validation.ValidationError;\n/**\n * Valid address prefixes.\n *\n * @private\n */\n\nexports.VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix\n * @returns {boolean}\n */\n\nfunction isValidPrefix(prefix) {\n  return hasSingleCase(prefix) && exports.VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @returns {Uint8Array}\n */\n\n\nfunction prefixToUint5Array(prefix) {\n  const result = new Uint8Array(prefix.length);\n\n  for (let i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n\n  return result;\n}\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\n\n\nfunction checksumToUint5Array(checksum) {\n  const result = new Uint8Array(8);\n\n  for (let i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n\n  return result;\n}\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\n\n\nfunction getTypeBits(type) {\n  switch (type) {\n    case 'P2PKH':\n      return 0;\n\n    case 'P2SH':\n      return 8;\n\n    default:\n      throw new exports.ValidationError('Invalid type: ' + type + '.');\n  }\n}\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\n\n\nfunction getType(versionByte) {\n  switch (versionByte & 0x78) {\n    case 0:\n      return 'P2PKH';\n\n    case 8:\n      return 'P2SH';\n\n    default:\n      throw new exports.ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n  }\n}\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\n\n\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n    case 160:\n      return 0;\n\n    case 192:\n      return 1;\n\n    case 224:\n      return 2;\n\n    case 256:\n      return 3;\n\n    case 320:\n      return 4;\n\n    case 384:\n      return 5;\n\n    case 448:\n      return 6;\n\n    case 512:\n      return 7;\n\n    default:\n      throw new exports.ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n * @throws {ValidationError}\n */\n\n\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n    case 0:\n      return 160;\n\n    case 1:\n      return 192;\n\n    case 2:\n      return 224;\n\n    case 3:\n      return 256;\n\n    case 4:\n      return 320;\n\n    case 5:\n      return 384;\n\n    case 6:\n      return 448;\n\n    case 7:\n      return 512;\n\n    default:\n      throw new exports.ValidationError('Invalid versionByte: ' + (versionByte & 7) + '.');\n  }\n}\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\n\n\nfunction toUint5Array(data) {\n  return convertBits_1.convertBits(data, 8, 5);\n}\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\n\n\nfunction fromUint5Array(data) {\n  return convertBits_1.convertBits(data, 5, 8, true);\n}\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a\n * @param {Uint8Array} b\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\n\n\nfunction concat(a, b) {\n  const ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\n\n\nfunction polymod(data) {\n  const GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n  let checksum = bigInt(1);\n\n  for (const value of data) {\n    const topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n\n    for (let j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n\n  return checksum.xor(1);\n}\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\n\n\nfunction validChecksum(prefix, payload) {\n  const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  const checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\n\n\nfunction hasSingleCase(strng) {\n  return strng === strng.toLowerCase() || strng === strng.toUpperCase();\n}","map":{"version":3,"sources":["/Users/massimilianoalbini/Documents/gain-drop/node_modules/@shapeshiftoss/bitcoinjs-lib/src/cashaddr/index.js"],"names":["Object","defineProperty","exports","value","bigInt","require","base32","convertBits_1","validation","validate","encode","prefix","type","hash","isValidPrefix","Uint8Array","prefixData","concat","prefixToUint5Array","versionByte","getTypeBits","getHashSizeBits","payloadData","toUint5Array","checksumData","payload","checksumToUint5Array","polymod","decode","address","hasSingleCase","pieces","toLowerCase","split","length","validChecksum","fromUint5Array","subarray","getHashSize","getType","ValidationError","VALID_PREFIXES","indexOf","result","i","charCodeAt","checksum","and","toJSNumber","shiftRight","data","convertBits","a","b","ab","set","GENERATOR","topBits","shiftLeft","xor","j","equals","strng","toUpperCase"],"mappings":"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","sourcesContent":["'use strict';\n/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bigInt = require('big-integer');\nconst base32 = require('./base32');\nconst convertBits_1 = require('./convertBits');\nconst validation = require('./validation');\nconst validate = validation.validate;\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md}\n * @module cashaddr\n */\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n *\n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction encode(prefix, type, hash) {\n  validate(\n    typeof prefix === 'string' && isValidPrefix(prefix),\n    'Invalid prefix: ' + prefix + '.',\n  );\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  const versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  const payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n  const checksumData = concat(\n    concat(prefixData, payloadData),\n    new Uint8Array(8),\n  );\n  const payload = concat(\n    payloadData,\n    checksumToUint5Array(polymod(checksumData)),\n  );\n  return prefix + ':' + base32.encode(payload);\n}\nexports.encode = encode;\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n *\n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\nfunction decode(address) {\n  validate(\n    typeof address === 'string' && hasSingleCase(address),\n    'Invalid address: ' + address + '.',\n  );\n  const pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  const prefix = pieces[0];\n  const payload = base32.decode(pieces[1]);\n  validate(\n    validChecksum(prefix, payload),\n    'Invalid checksum: ' + address + '.',\n  );\n  const payloadData = fromUint5Array(payload.subarray(0, -8));\n  const versionByte = payloadData[0];\n  const hash = payloadData.subarray(1);\n  validate(\n    getHashSize(versionByte) === hash.length * 8,\n    'Invalid hash size: ' + address + '.',\n  );\n  const type = getType(versionByte);\n  return {\n    prefix,\n    type,\n    hash,\n  };\n}\nexports.decode = decode;\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nexports.ValidationError = validation.ValidationError;\n/**\n * Valid address prefixes.\n *\n * @private\n */\nexports.VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix\n * @returns {boolean}\n */\nfunction isValidPrefix(prefix) {\n  return (\n    hasSingleCase(prefix) &&\n    exports.VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1\n  );\n}\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @returns {Uint8Array}\n */\nfunction prefixToUint5Array(prefix) {\n  const result = new Uint8Array(prefix.length);\n  for (let i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n  return result;\n}\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\nfunction checksumToUint5Array(checksum) {\n  const result = new Uint8Array(8);\n  for (let i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n  return result;\n}\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n  switch (type) {\n    case 'P2PKH':\n      return 0;\n    case 'P2SH':\n      return 8;\n    default:\n      throw new exports.ValidationError('Invalid type: ' + type + '.');\n  }\n}\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction getType(versionByte) {\n  switch (versionByte & 0x78) {\n    case 0:\n      return 'P2PKH';\n    case 8:\n      return 'P2SH';\n    default:\n      throw new exports.ValidationError(\n        'Invalid address type in version byte: ' + versionByte + '.',\n      );\n  }\n}\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n    case 160:\n      return 0;\n    case 192:\n      return 1;\n    case 224:\n      return 2;\n    case 256:\n      return 3;\n    case 320:\n      return 4;\n    case 384:\n      return 5;\n    case 448:\n      return 6;\n    case 512:\n      return 7;\n    default:\n      throw new exports.ValidationError(\n        'Invalid hash size: ' + hash.length + '.',\n      );\n  }\n}\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n    case 0:\n      return 160;\n    case 1:\n      return 192;\n    case 2:\n      return 224;\n    case 3:\n      return 256;\n    case 4:\n      return 320;\n    case 5:\n      return 384;\n    case 6:\n      return 448;\n    case 7:\n      return 512;\n    default:\n      throw new exports.ValidationError(\n        'Invalid versionByte: ' + (versionByte & 7) + '.',\n      );\n  }\n}\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction toUint5Array(data) {\n  return convertBits_1.convertBits(data, 8, 5);\n}\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n  return convertBits_1.convertBits(data, 5, 8, true);\n}\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a\n * @param {Uint8Array} b\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n  const ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\nfunction polymod(data) {\n  const GENERATOR = [\n    0x98f2bc8e61,\n    0x79b76d99e2,\n    0xf33e5fb3c4,\n    0xae2eabe2a8,\n    0x1e4f43e470,\n  ];\n  let checksum = bigInt(1);\n  for (const value of data) {\n    const topBits = checksum.shiftRight(35);\n    checksum = checksum\n      .and(0x07ffffffff)\n      .shiftLeft(5)\n      .xor(value);\n    for (let j = 0; j < GENERATOR.length; ++j) {\n      if (\n        topBits\n          .shiftRight(j)\n          .and(1)\n          .equals(1)\n      ) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n  return checksum.xor(1);\n}\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\nfunction validChecksum(prefix, payload) {\n  const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  const checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\nfunction hasSingleCase(strng) {\n  return strng === strng.toLowerCase() || strng === strng.toUpperCase();\n}\n"]},"metadata":{},"sourceType":"script"}