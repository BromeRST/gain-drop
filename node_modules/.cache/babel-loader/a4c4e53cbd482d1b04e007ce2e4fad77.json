{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rippleGetAddress = exports.rippleSignTx = exports.rippleGetAccountPaths = void 0;\n\nconst RippleMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-ripple_pb\"));\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nfunction rippleGetAccountPaths(msg) {\n  return [{\n    addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Ripple\"), 0x80000000 + msg.accountIdx, 0, 0]\n  }];\n}\n\nexports.rippleGetAccountPaths = rippleGetAccountPaths;\n\nfunction rippleSignTx(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n      const signTx = new RippleMessages.RippleSignTx();\n      signTx.setAddressNList(msg.addressNList);\n      signTx.setFee(parseInt(msg.tx.value.fee.amount[0].amount));\n      signTx.setSequence(parseInt(msg.sequence));\n      signTx.setLastLedgerSequence(parseInt(msg.lastLedgerSequence));\n      const payment = new RippleMessages.RipplePayment();\n      payment.setAmount(parseInt(msg.payment.amount));\n      payment.setDestination(msg.payment.destination);\n      if (msg.payment.destinationTag !== undefined) payment.setDestinationTag(parseInt(msg.payment.destinationTag));\n      signTx.setPayment(payment);\n      let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_RIPPLESIGNTX, signTx, {\n        msgTimeout: core.LONG_TIMEOUT,\n        omitLock: true\n      });\n\n      for (let m of msg.tx.value.msg) {\n        let ack;\n\n        if (m.type === \"ripple-sdk/MsgSend\") {\n          if (m.value.amount.length !== 1) {\n            throw new Error(\"ripple: Multiple amounts per msg not supported\");\n          }\n\n          const denom = m.value.amount[0].denom;\n\n          if (denom !== \"drop\") {\n            throw new Error(\"ripple: Unsupported denomination: \" + denom);\n          }\n        } else {\n          throw new Error(`ripple: Message ${m.type} is not yet supported`);\n        }\n      }\n\n      if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_RIPPLESIGNEDTX) {\n        throw new Error(`ripple: unexpected response ${resp.message_type}`);\n      }\n\n      const signedTx = resp.proto;\n      const signed = lodash_1.default.cloneDeep(msg.tx);\n      signed.value.signatures = [{\n        serializedTx: signedTx.getSerializedTx_asB64(),\n        signature: signedTx.getSignature_asB64()\n      }];\n      return signed;\n    }));\n  });\n}\n\nexports.rippleSignTx = rippleSignTx;\n\nfunction rippleGetAddress(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const getAddr = new RippleMessages.RippleGetAddress();\n    getAddr.setAddressNList(msg.addressNList);\n    getAddr.setShowDisplay(msg.showDisplay !== false);\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_RIPPLEGETADDRESS, getAddr, {\n      msgTimeout: core.LONG_TIMEOUT\n    });\n    const rippleAddress = response.proto;\n    return core.mustBeDefined(rippleAddress.getAddress());\n  });\n}\n\nexports.rippleGetAddress = rippleGetAddress;","map":{"version":3,"mappings":"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","names":["rippleGetAccountPaths","msg","addressNList","core","slip44ByCoin","accountIdx","exports","rippleSignTx","transport","lockDuring","__awaiter","signTx","RippleMessages","RippleSignTx","setAddressNList","setFee","parseInt","tx","value","fee","amount","setSequence","sequence","setLastLedgerSequence","lastLedgerSequence","payment","RipplePayment","setAmount","setDestination","destination","destinationTag","undefined","setDestinationTag","setPayment","resp","call","Messages","MessageType","MESSAGETYPE_RIPPLESIGNTX","msgTimeout","LONG_TIMEOUT","omitLock","m","ack","type","length","Error","denom","message_enum","MESSAGETYPE_RIPPLESIGNEDTX","message_type","signedTx","proto","signed","lodash_1","cloneDeep","signatures","serializedTx","getSerializedTx_asB64","signature","getSignature_asB64","rippleGetAddress","getAddr","RippleGetAddress","setShowDisplay","showDisplay","response","MESSAGETYPE_RIPPLEGETADDRESS","rippleAddress","mustBeDefined","getAddress"],"sourceRoot":"","sources":["../src/ripple.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}