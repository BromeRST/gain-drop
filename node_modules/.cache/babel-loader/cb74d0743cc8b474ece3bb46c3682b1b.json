{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar HDKey = _interopDefault(require('hdkey'));\n\nvar ethereumjsUtil = require('ethereumjs-util');\n\nvar tx = require('@ethereumjs/tx');\n\nvar bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');\n\nvar uuid = require('uuid');\n\nconst keyringType = 'QR Hardware Wallet Device';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\n\nclass BaseKeyring {\n  constructor(opts) {\n    this.getInteraction = () => {\n      throw new Error('#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.');\n    };\n\n    this.type = keyringType;\n\n    this.readKeyringCryptoHDKey = async () => {\n      var _cryptoHDKey$getOrigi;\n\n      const cryptoHDKey = await this.getInteraction().readCryptoHDKey();\n      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;\n      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString('hex');\n\n      if (!xfp) {\n        throw new Error('invalid crypto-hd-key, cannot get source fingerprint');\n      }\n\n      const xpub = cryptoHDKey.getBip32Key();\n      return {\n        xfp,\n        xpub,\n        hdPath\n      };\n    };\n\n    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {\n      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);\n      const requestIdBuffer = ethSignature.getRequestId();\n      const signature = ethSignature.getSignature();\n\n      if (requestIdBuffer) {\n        const requestId = uuid.stringify(requestIdBuffer);\n\n        if (requestId !== _requestId) {\n          throw new Error('read signature error: mismatched requestId');\n        }\n      }\n\n      const r = signature.slice(0, 32);\n      const s = signature.slice(32, 64);\n      const v = signature.slice(64);\n      return {\n        r,\n        s,\n        v\n      };\n    };\n\n    this.xfp = '';\n    this.xpub = '';\n    this.hdPath = '';\n    this.page = 0;\n    this.perPage = 5;\n    this.accounts = [];\n    this.currentAccount = 0;\n    this.paths = {};\n    this.latestAccount = 0;\n    this.deserialize(opts);\n  }\n\n  async readKeyring() {\n    const {\n      xpub,\n      xfp,\n      hdPath\n    } = await this.readKeyringCryptoHDKey();\n    this.xfp = xfp;\n    this.xpub = xpub;\n    this.hdPath = hdPath;\n  }\n\n  checkKeyring() {\n    if (!this.xfp || !this.xpub || !this.hdPath) {\n      throw new Error('keyring not fulfilled, please call function `readKeyring` firstly');\n    }\n  }\n\n  serialize() {\n    return Promise.resolve({\n      xfp: this.xfp,\n      xpub: this.xpub,\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      currentAccount: this.currentAccount,\n      page: this.page,\n      perPage: this.perPage,\n      paths: this.paths\n    });\n  }\n\n  deserialize(opts) {\n    if (opts) {\n      this.xfp = opts.xfp;\n      this.xpub = opts.xpub;\n      this.hdPath = opts.hdPath;\n      this.accounts = opts.accounts;\n      this.currentAccount = opts.currentAccount;\n      this.page = opts.page;\n      this.perPage = opts.perPage;\n      this.paths = opts.paths;\n    }\n  }\n\n  setCurrentAccount(index) {\n    this.currentAccount = index;\n  }\n\n  getCurrentAccount() {\n    return this.currentAccount;\n  }\n\n  getCurrentAddress() {\n    return this.accounts[this.currentAccount];\n  }\n\n  addAccounts() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return new Promise((resolve, reject) => {\n      try {\n        const from = this.latestAccount;\n        const to = from + n;\n        const newAccounts = [];\n\n        for (let i = from; i < to; i++) {\n          const address = this._addressFromIndex(pathBase, i);\n\n          newAccounts.push(address);\n          this.page = 0;\n          this.latestAccount++;\n        }\n\n        this.accounts = this.accounts.concat(newAccounts);\n        resolve(this.accounts);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this.__getPage(1);\n  }\n\n  getNextPage() {\n    return this.__getPage(1);\n  }\n\n  getPreviousPage() {\n    return this.__getPage(-1);\n  }\n\n  async __getPage(increment) {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n\n    if (!!!this.xfp) {\n      await this.readKeyring();\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        const from = (this.page - 1) * this.perPage;\n        const to = from + this.perPage;\n        const accounts = [];\n\n        for (let i = from; i < to; i++) {\n          const address = this._addressFromIndex(pathBase, i);\n\n          accounts.push({\n            address,\n            balance: null,\n            index: i\n          });\n          this.paths[ethereumjsUtil.toChecksumAddress(address)] = i;\n        }\n\n        resolve(accounts);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts);\n  }\n\n  removeAccount(address) {\n    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n\n    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());\n  } // tx is an instance of the ethereumjs-transaction class.\n\n\n  static serializeTx(tx) {\n    // need use EIP-155\n    // @ts-ignore\n    tx.v = new ethereumjsUtil.BN(tx.common.chainId()); // @ts-ignore\n\n    tx.r = new ethereumjsUtil.BN(0); // @ts-ignore\n\n    tx.s = new ethereumjsUtil.BN(0);\n    return tx.serialize();\n  }\n\n  async signTransaction(address, tx$1) {\n    const hdPath = this._pathFromAddress(address);\n\n    const chainId = tx$1.common.chainId();\n    const requestId = uuid.v4();\n    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(BaseKeyring.serializeTx(tx$1), bcUrRegistryEth.DataType.transaction, hdPath, this.xfp, requestId, chainId);\n    const {\n      r,\n      s,\n      v\n    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature');\n    const txJson = tx$1.toJSON();\n    return tx.Transaction.fromTxData({\n      to: txJson['to'],\n      gasLimit: txJson['gasLimit'],\n      gasPrice: txJson['gasPrice'],\n      data: txJson['data'],\n      nonce: txJson['nonce'],\n      value: txJson['value'],\n      r,\n      s,\n      v\n    }, {\n      common: tx$1.common\n    });\n  }\n\n  signMessage(withAccount, data) {\n    return this.signPersonalMessage(withAccount, data);\n  }\n\n  async signPersonalMessage(withAccount, messageHex) {\n    const usignedHex = ethereumjsUtil.stripHexPrefix(messageHex);\n\n    const hdPath = this._pathFromAddress(withAccount);\n\n    const requestId = uuid.v4();\n    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, 'hex'), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);\n    const {\n      r,\n      s,\n      v\n    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature');\n    return '0x' + Buffer.concat([r, s, v]).toString('hex');\n  }\n\n  async signTypedData(withAccount, typedData) {\n    const hdPath = this._pathFromAddress(withAccount);\n\n    const requestId = uuid.v4();\n    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), 'utf-8'), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);\n    const {\n      r,\n      s,\n      v\n    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this data, click on \"Scan Keystone\" to receive the signature');\n    return '0x' + Buffer.concat([r, s, v]).toString('hex');\n  }\n\n  _addressFromIndex(pb, i) {\n    this.checkKeyring();\n\n    if (!this.hdk) {\n      // @ts-ignore\n      this.hdk = HDKey.fromExtendedKey(this.xpub);\n    }\n\n    const dkey = this.hdk.derive(`${pb}/0/${i}`);\n    const address = '0x' + ethereumjsUtil.publicToAddress(dkey.publicKey, true).toString('hex');\n    return ethereumjsUtil.toChecksumAddress(address);\n  }\n\n  _pathFromAddress(address) {\n    const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n\n    return `${this.hdPath}/0/${index}`;\n  }\n\n}\n\nBaseKeyring.type = keyringType;\nexports.BaseKeyring = BaseKeyring;","map":{"version":3,"mappings":"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","names":["keyringType","pathBase","MAX_INDEX","BaseKeyring","constructor","opts","Error","cryptoHDKey","getInteraction","readCryptoHDKey","hdPath","getOrigin","getPath","xfp","getSourceFingerprint","_cryptoHDKey$getOrigi","toString","xpub","getBip32Key","_requestId","signRequest","requestTitle","requestDescription","ethSignature","requestSignature","requestIdBuffer","getRequestId","signature","getSignature","requestId","uuid","r","slice","s","v","page","perPage","accounts","currentAccount","paths","latestAccount","deserialize","readKeyring","readKeyringCryptoHDKey","checkKeyring","serialize","Promise","resolve","setCurrentAccount","index","getCurrentAccount","getCurrentAddress","addAccounts","n","reject","from","to","newAccounts","i","address","_addressFromIndex","push","concat","e","getFirstPage","__getPage","getNextPage","getPreviousPage","increment","balance","toChecksumAddress","getAccounts","removeAccount","map","a","toLowerCase","includes","filter","serializeTx","tx","BN","common","chainId","signTransaction","_pathFromAddress","ethSignRequest","EthSignRequest","constructETHRequest","DataType","transaction","txJson","toJSON","Transaction","fromTxData","gasLimit","gasPrice","data","nonce","value","signMessage","withAccount","signPersonalMessage","messageHex","usignedHex","stripHexPrefix","Buffer","personalMessage","undefined","signTypedData","typedData","JSON","stringify","pb","hdk","HDKey","fromExtendedKey","dkey","derive","publicToAddress","publicKey","checksummedAddress"],"sources":["../src/BaseKeyring.ts"],"sourcesContent":["import HDKey from 'hdkey';\nimport { toChecksumAddress, publicToAddress, BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Transaction } from '@ethereumjs/tx';\nimport { DataType, EthSignRequest } from '@keystonehq/bc-ur-registry-eth';\nimport * as uuid from 'uuid';\nimport { InteractionProvider } from './InteractionProvider';\n\nconst keyringType = 'QR Hardware Wallet Device';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\n\nexport type StoredKeyring = {\n    xfp: string;\n    xpub: string;\n    hdPath: string;\n    accounts: string[];\n    currentAccount: number;\n    page: number;\n    perPage: number;\n    paths: Record<string, number>;\n};\n\nexport type PagedAccount = { address: string; balance: any; index: number };\n\nexport class BaseKeyring {\n    getInteraction = (): InteractionProvider => {\n        throw new Error(\n            '#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.',\n        );\n    };\n    static type = keyringType;\n    protected xfp: string;\n    protected type = keyringType;\n    protected xpub: string;\n    protected hdPath: string;\n    protected accounts: string[];\n    protected currentAccount: number;\n    protected page: number;\n    protected perPage: number;\n    protected paths: Record<string, number>;\n    protected hdk: HDKey;\n    protected latestAccount: number;\n\n    constructor(opts?: StoredKeyring) {\n        this.xfp = '';\n        this.xpub = '';\n        this.hdPath = '';\n        this.page = 0;\n        this.perPage = 5;\n        this.accounts = [];\n        this.currentAccount = 0;\n        this.paths = {};\n        this.latestAccount = 0;\n        this.deserialize(opts);\n    }\n\n    private readKeyringCryptoHDKey = async (): Promise<{ xfp: string; xpub: string; hdPath: string }> => {\n        const cryptoHDKey = await this.getInteraction().readCryptoHDKey();\n        const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;\n        const xfp = cryptoHDKey.getOrigin().getSourceFingerprint()?.toString('hex');\n        if (!xfp) {\n            throw new Error('invalid crypto-hd-key, cannot get source fingerprint');\n        }\n        const xpub = cryptoHDKey.getBip32Key();\n        return {\n            xfp,\n            xpub,\n            hdPath,\n        };\n    };\n\n    protected requestSignature = async (\n        _requestId: string,\n        signRequest: EthSignRequest,\n        requestTitle?: string,\n        requestDescription?: string,\n    ): Promise<{ r: Buffer; s: Buffer; v: Buffer }> => {\n        const ethSignature = await this.getInteraction().requestSignature(\n            signRequest,\n            requestTitle,\n            requestDescription,\n        );\n        const requestIdBuffer = ethSignature.getRequestId();\n        const signature = ethSignature.getSignature();\n        if (requestIdBuffer) {\n            const requestId = uuid.stringify(requestIdBuffer);\n            if (requestId !== _requestId) {\n                throw new Error('read signature error: mismatched requestId');\n            }\n        }\n        const r = signature.slice(0, 32);\n        const s = signature.slice(32, 64);\n        const v = signature.slice(64);\n        return {\n            r,\n            s,\n            v,\n        };\n    };\n\n    async readKeyring(): Promise<void> {\n        const { xpub, xfp, hdPath } = await this.readKeyringCryptoHDKey();\n        this.xfp = xfp;\n        this.xpub = xpub;\n        this.hdPath = hdPath;\n    }\n\n    protected checkKeyring() {\n        if (!this.xfp || !this.xpub || !this.hdPath) {\n            throw new Error('keyring not fulfilled, please call function `readKeyring` firstly');\n        }\n    }\n\n    serialize(): Promise<StoredKeyring> {\n        return Promise.resolve({\n            xfp: this.xfp,\n            xpub: this.xpub,\n            hdPath: this.hdPath,\n            accounts: this.accounts,\n            currentAccount: this.currentAccount,\n            page: this.page,\n            perPage: this.perPage,\n            paths: this.paths,\n        });\n    }\n\n    deserialize(opts?: StoredKeyring): void {\n        if (opts) {\n            this.xfp = opts.xfp;\n            this.xpub = opts.xpub;\n            this.hdPath = opts.hdPath;\n            this.accounts = opts.accounts;\n            this.currentAccount = opts.currentAccount;\n            this.page = opts.page;\n            this.perPage = opts.perPage;\n            this.paths = opts.paths;\n        }\n    }\n\n    setCurrentAccount(index: number): void {\n        this.currentAccount = index;\n    }\n\n    getCurrentAccount(): number {\n        return this.currentAccount;\n    }\n\n    getCurrentAddress(): string {\n        return this.accounts[this.currentAccount];\n    }\n\n    addAccounts(n = 1): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            try {\n                const from = this.latestAccount;\n                const to = from + n;\n                const newAccounts = [];\n\n                for (let i = from; i < to; i++) {\n                    const address = this._addressFromIndex(pathBase, i);\n                    newAccounts.push(address);\n                    this.page = 0;\n                    this.latestAccount++;\n                }\n                this.accounts = this.accounts.concat(newAccounts);\n                resolve(this.accounts);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    getFirstPage(): Promise<PagedAccount[]> {\n        this.page = 0;\n        return this.__getPage(1);\n    }\n\n    getNextPage(): Promise<PagedAccount[]> {\n        return this.__getPage(1);\n    }\n\n    getPreviousPage(): Promise<PagedAccount[]> {\n        return this.__getPage(-1);\n    }\n\n    async __getPage(increment: number): Promise<PagedAccount[]> {\n        this.page += increment;\n\n        if (this.page <= 0) {\n            this.page = 1;\n        }\n\n        if (!!!this.xfp) {\n            await this.readKeyring();\n        }\n\n        return new Promise((resolve, reject) => {\n            try {\n                const from = (this.page - 1) * this.perPage;\n                const to = from + this.perPage;\n\n                const accounts = [];\n\n                for (let i = from; i < to; i++) {\n                    const address = this._addressFromIndex(pathBase, i);\n                    accounts.push({\n                        address,\n                        balance: null,\n                        index: i,\n                    });\n                    this.paths[toChecksumAddress(address)] = i;\n                }\n                resolve(accounts);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    getAccounts() {\n        return Promise.resolve(this.accounts);\n    }\n\n    removeAccount(address: string): void {\n        if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {\n            throw new Error(`Address ${address} not found in this keyring`);\n        }\n        this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase());\n    }\n\n    // tx is an instance of the ethereumjs-transaction class.\n\n    private static serializeTx(tx: Transaction): Buffer {\n        // need use EIP-155\n        // @ts-ignore\n        tx.v = new BN(tx.common.chainId());\n        // @ts-ignore\n        tx.r = new BN(0);\n        // @ts-ignore\n        tx.s = new BN(0);\n        return tx.serialize();\n    }\n\n    async signTransaction(address: string, tx: Transaction): Promise<Transaction> {\n        const hdPath = this._pathFromAddress(address);\n        const chainId = tx.common.chainId();\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            BaseKeyring.serializeTx(tx),\n            DataType.transaction,\n            hdPath,\n            this.xfp,\n            requestId,\n            chainId,\n        );\n\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature',\n        );\n        const txJson = tx.toJSON();\n        return Transaction.fromTxData(\n            {\n                to: txJson['to'],\n                gasLimit: txJson['gasLimit'],\n                gasPrice: txJson['gasPrice'],\n                data: txJson['data'],\n                nonce: txJson['nonce'],\n                value: txJson['value'],\n                r,\n                s,\n                v,\n            },\n            { common: tx.common },\n        );\n    }\n\n    signMessage(withAccount: string, data: string): Promise<string> {\n        return this.signPersonalMessage(withAccount, data);\n    }\n\n    async signPersonalMessage(withAccount: string, messageHex: string): Promise<string> {\n        const usignedHex = stripHexPrefix(messageHex);\n        const hdPath = this._pathFromAddress(withAccount);\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            Buffer.from(usignedHex, 'hex'),\n            DataType.personalMessage,\n            hdPath,\n            this.xfp,\n            requestId,\n            undefined,\n            withAccount,\n        );\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature',\n        );\n        return '0x' + Buffer.concat([r, s, v]).toString('hex');\n    }\n\n    async signTypedData(withAccount: string, typedData: any): Promise<string> {\n        const hdPath = this._pathFromAddress(withAccount);\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            Buffer.from(JSON.stringify(typedData), 'utf-8'),\n            DataType.typedData,\n            hdPath,\n            this.xfp,\n            requestId,\n            undefined,\n            withAccount,\n        );\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed this data, click on \"Scan Keystone\" to receive the signature',\n        );\n        return '0x' + Buffer.concat([r, s, v]).toString('hex');\n    }\n\n    _addressFromIndex(pb: string, i: number): string {\n        this.checkKeyring();\n        if (!this.hdk) {\n            // @ts-ignore\n            this.hdk = HDKey.fromExtendedKey(this.xpub);\n        }\n        const dkey = this.hdk.derive(`${pb}/0/${i}`);\n        const address = '0x' + publicToAddress(dkey.publicKey, true).toString('hex');\n        return toChecksumAddress(address);\n    }\n\n    _pathFromAddress(address: string): string {\n        const checksummedAddress = toChecksumAddress(address);\n        let index = this.paths[checksummedAddress];\n        if (typeof index === 'undefined') {\n            for (let i = 0; i < MAX_INDEX; i++) {\n                if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n\n        if (typeof index === 'undefined') {\n            throw new Error('Unknown address');\n        }\n        return `${this.hdPath}/0/${index}`;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}