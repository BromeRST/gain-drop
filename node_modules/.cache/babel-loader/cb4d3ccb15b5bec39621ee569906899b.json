{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst cashaddr = require('./cashaddr');\n\nconst networks = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst types = require('./types');\n\nconst bech32 = require('bech32');\n\nconst bs58check = require('bs58check');\n\nconst typeforce = require('typeforce');\n\nfunction fromBase58Check(address) {\n  const isBCH = cashaddr.VALID_PREFIXES.indexOf(address.split(':')[0]) > -1;\n\n  if (isBCH) {\n    const result = cashaddr.decode(address);\n    let network;\n\n    switch (result.prefix) {\n      case 'bitcoincash':\n        network = networks.bitcoin;\n        break;\n\n      case 'bchtest':\n        network = networks.testnet;\n        break;\n\n      case 'bchreg':\n        network = networks.regtest;\n        break;\n    }\n\n    let version;\n\n    switch (result.type) {\n      case 'P2PKH':\n        version = network.pubKeyHash;\n        break;\n\n      case 'P2SH':\n        version = network.scriptHash;\n        break;\n    }\n\n    if (result.hash.length < 20) throw new TypeError(address + ' is too short');\n    if (result.hash.length > 20) throw new TypeError(address + ' is too long');\n    return {\n      version: version,\n      hash: Buffer.from(result.hash)\n    };\n  } else {\n    const payload = bs58check.decode(address); // TODO: 4.0.0, move to \"toOutputScript\"\n\n    if (payload.length < 21) throw new TypeError(address + ' is too short');\n    if (payload.length > 21) throw new TypeError(address + ' is too long');\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return {\n      version,\n      hash\n    };\n  }\n}\n\nexports.fromBase58Check = fromBase58Check;\n\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n}\n\nexports.fromBech32 = fromBech32;\n\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\n\nexports.toBase58Check = toBase58Check;\n\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\n\nexports.toBech32 = toBech32;\n\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n\n  try {\n    return payments.p2pkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2sh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2wpkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2wsh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\n\nexports.fromOutputScript = fromOutputScript;\n\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash) return payments.p2pkh({\n      hash: decodeBase58.hash\n    }).output;\n    if (decodeBase58.version === network.scriptHash) return payments.p2sh({\n      hash: decodeBase58.hash\n    }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');\n\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20) return payments.p2wpkh({\n          hash: decodeBech32.data\n        }).output;\n        if (decodeBech32.data.length === 32) return payments.p2wsh({\n          hash: decodeBech32.data\n        }).output;\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script');\n}\n\nexports.toOutputScript = toOutputScript;","map":{"version":3,"sources":["/Users/massimilianoalbini/Documents/gain-drop/gain-drop/node_modules/@shapeshiftoss/bitcoinjs-lib/src/address.js"],"names":["Object","defineProperty","exports","value","cashaddr","require","networks","payments","bscript","types","bech32","bs58check","typeforce","fromBase58Check","address","isBCH","VALID_PREFIXES","indexOf","split","result","decode","network","prefix","bitcoin","testnet","regtest","version","type","pubKeyHash","scriptHash","hash","length","TypeError","Buffer","from","payload","readUInt8","slice","fromBech32","data","fromWords","words","toBase58Check","tuple","Hash160bit","UInt8","arguments","allocUnsafe","writeUInt8","copy","encode","toBech32","toWords","unshift","fromOutputScript","output","p2pkh","e","p2sh","p2wpkh","p2wsh","Error","toASM","toOutputScript","decodeBase58","decodeBech32"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst cashaddr = require('./cashaddr');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types = require('./types');\nconst bech32 = require('bech32');\nconst bs58check = require('bs58check');\nconst typeforce = require('typeforce');\nfunction fromBase58Check(address) {\n  const isBCH = cashaddr.VALID_PREFIXES.indexOf(address.split(':')[0]) > -1;\n  if (isBCH) {\n    const result = cashaddr.decode(address);\n    let network;\n    switch (result.prefix) {\n      case 'bitcoincash':\n        network = networks.bitcoin;\n        break;\n      case 'bchtest':\n        network = networks.testnet;\n        break;\n      case 'bchreg':\n        network = networks.regtest;\n        break;\n    }\n    let version;\n    switch (result.type) {\n      case 'P2PKH':\n        version = network.pubKeyHash;\n        break;\n      case 'P2SH':\n        version = network.scriptHash;\n        break;\n    }\n    if (result.hash.length < 20) throw new TypeError(address + ' is too short');\n    if (result.hash.length > 20) throw new TypeError(address + ' is too long');\n    return {\n      version: version,\n      hash: Buffer.from(result.hash),\n    };\n  } else {\n    const payload = bs58check.decode(address);\n    // TODO: 4.0.0, move to \"toOutputScript\"\n    if (payload.length < 21) throw new TypeError(address + ' is too short');\n    if (payload.length > 21) throw new TypeError(address + ' is too long');\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  }\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n"]},"metadata":{},"sourceType":"script"}