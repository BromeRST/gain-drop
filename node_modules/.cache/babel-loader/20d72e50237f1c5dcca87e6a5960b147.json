{"ast":null,"code":"/**\n * This allows you to work with object hierarchies that have been frozen\n * with Object.freeze().  \"get\" operations can use the normal JS syntax,\n * but operations that modify the data will have to return partial copies of\n * the structure. The portions of the structure that did not change will\n * === their previous values.\n *\n * Inspired by clojure/mori and Immutable.js\n */\n'use strict';\n\nconst i = exports;\n\nconst identity = coll => coll; // we only care about objects or arrays for now\n\n\nconst weCareAbout = val => val !== null && (Array.isArray(val) || // This will skip objects created with `new Foo()`\n// and objects created with `Object.create(proto)`\n// The benefit is ignoring DOM elements and event emitters,\n// which are often circular.\nisObjectLike(val));\n\nconst isObjectLike = val => typeof val === 'object' && (val.constructor === Object || val.constructor == null) && (Object.getPrototypeOf(val) === Object.prototype || Object.getPrototypeOf(val) === null);\n\nconst forKeys = (obj, iter) => {\n  let idx, keys;\n\n  if (Array.isArray(obj)) {\n    idx = obj.length;\n\n    while (idx--) {\n      iter(idx);\n    }\n\n    return;\n  }\n\n  keys = Object.keys(obj);\n  idx = keys.length;\n\n  while (idx--) {\n    iter(keys[idx]);\n  }\n};\n\nconst cloneObj = obj => {\n  const newObj = obj.constructor == null ? Object.create(null) : {};\n  const keys = Object.keys(obj);\n  let idx = keys.length;\n  let key;\n\n  while (idx--) {\n    key = keys[idx];\n    newObj[key] = obj[key];\n  }\n\n  return newObj;\n};\n\nconst clone = coll => {\n  if (Array.isArray(coll)) {\n    return coll.slice();\n  } else {\n    return cloneObj(coll);\n  }\n};\n\nconst freezeIfNeeded = process.env.NODE_ENV === 'production' ? identity : coll => {\n  if (weCareAbout(coll) && !Object.isFrozen(coll)) {\n    return baseFreeze(coll);\n  }\n\n  return coll;\n};\n\nconst _freeze = process.env.NODE_ENV === 'production' ? identity : coll => {\n  if (typeof coll === 'object') {\n    return Object.freeze(coll);\n  } else {\n    return coll;\n  }\n};\n\nconst prevNodes = [];\n\nconst baseFreeze = coll => {\n  if (prevNodes.some(val => val === coll)) {\n    throw new Error('object has a reference cycle');\n  }\n\n  prevNodes.push(coll);\n  forKeys(coll, key => {\n    const prop = coll[key];\n\n    if (weCareAbout(prop)) {\n      baseFreeze(prop);\n    }\n  });\n  prevNodes.pop();\n  Object.freeze(coll);\n  return coll;\n};\n/**\n * recrursively freeze an object and all its child objects\n * @param  {Object|Array} coll\n * @return {Object|Array}\n */\n\n\nexports.freeze = process.env.NODE_ENV === 'production' ? identity : baseFreeze;\n/**\n * recursively un-freeze an object, by cloning frozen collections\n * @param  {[type]} coll [description]\n * @return {[type]}      [description]\n */\n\nexports.thaw = function thaw(coll) {\n  if (!weCareAbout(coll) || !Object.isFrozen(coll)) return coll;\n  const newColl = Array.isArray(coll) ? new Array(coll.length) : {};\n  forKeys(coll, key => {\n    newColl[key] = thaw(coll[key]);\n  });\n  return newColl;\n};\n/**\n * set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key   Key or index\n * @param  {Object}        value\n * @return {Object|Array}        new object hierarchy with modifications\n */\n\n\nexports.assoc = function assoc(coll, key, value) {\n  if (coll[key] === value) {\n    return _freeze(coll);\n  }\n\n  const newObj = clone(coll);\n  newObj[key] = freezeIfNeeded(value);\n  return _freeze(newObj);\n};\n\nexports.set = exports.assoc;\n/**\n * un-set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key  Key or Index\n * @return {Object|Array}       New object or array\n */\n\nexports.dissoc = function dissoc(coll, key) {\n  const newObj = clone(coll);\n  delete newObj[key];\n  return _freeze(newObj);\n};\n\nexports.unset = exports.dissoc;\n/**\n * set a value deep in a hierarchical structure\n * @param  {Object|Array} coll\n * @param  {Array}        path    A list of keys to traverse\n * @param  {Object}       value\n * @return {Object|Array}       new object hierarchy with modifications\n */\n\nexports.assocIn = function assocIn(coll, path, value) {\n  const key0 = path[0];\n\n  if (path.length === 1) {\n    // simplest case is a 1-element array.  Just a simple assoc.\n    return i.assoc(coll, key0, value);\n  } else {\n    // break the problem down.  Assoc this object with the first key\n    // and the result of assocIn with the rest of the keys\n    return i.assoc(coll, key0, assocIn(coll[key0] || {}, path.slice(1), value));\n  }\n};\n\nexports.setIn = exports.assocIn;\n/**\n * un-set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {Array} path  A list of keys to traverse\n * @return {Object|Array}       New object or array\n */\n\nexports.dissocIn = function dissocIn(coll, path) {\n  const key0 = path[0];\n\n  if (!coll.hasOwnProperty(key0)) {\n    return coll;\n  }\n\n  if (path.length === 1) {\n    // simplest case is a 1-element array.  Just a simple dissoc.\n    return i.dissoc(coll, key0);\n  } else {\n    // break the problem down.  Assoc this object with the first key\n    // and the result of dissocIn with the rest of the keys\n    return i.assoc(coll, key0, dissocIn(coll[key0], path.slice(1)));\n  }\n};\n\nexports.unsetIn = exports.dissocIn;\n/**\n * get an object from a hierachy based on an array of keys\n * @param  {Object|Array} coll\n * @param  {Array}        path    list of keys\n * @return {Object}       value, or undefined\n */\n\nfunction baseGet(coll, path) {\n  return (path || []).reduce((curr, key) => {\n    if (!curr) {\n      return;\n    }\n\n    return curr[key];\n  }, coll);\n}\n\nexports.getIn = baseGet;\n/**\n * Update a value in a hierarchy\n * @param  {Object|Array}   coll\n * @param  {Array}          path     list of keys\n * @param  {Function} callback The existing value with be passed to this.\n *                             Return the new value to set\n * @return {Object|Array}      new object hierarchy with modifications\n */\n\nexports.updateIn = function updateIn(coll, path, callback) {\n  const existingVal = baseGet(coll, path);\n  return i.assocIn(coll, path, callback(existingVal));\n}; // generate wrappers for the mutative array methods\n\n\n['push', 'unshift', 'pop', 'shift', 'reverse', 'sort'].forEach(methodName => {\n  exports[methodName] = function (arr, val) {\n    const newArr = [...arr];\n    newArr[methodName](freezeIfNeeded(val));\n    return _freeze(newArr);\n  };\n\n  exports[methodName].displayName = 'icepick.' + methodName;\n}); // splice is special because it is variadic\n\nexports.splice = function splice(arr) {\n  const newArr = [...arr];\n\n  for (var _len = arguments.length, _args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    _args[_key - 1] = arguments[_key];\n  }\n\n  const args = _args.map(freezeIfNeeded);\n\n  newArr.splice.apply(newArr, args);\n  return _freeze(newArr);\n}; // slice is non-mutative\n\n\nexports.slice = function slice(arr, arg1, arg2) {\n  const newArr = arr.slice(arg1, arg2);\n  return _freeze(newArr);\n};\n\n['map', 'filter'].forEach(methodName => {\n  exports[methodName] = function (fn, arr) {\n    const newArr = arr[methodName](fn);\n    return _freeze(newArr);\n  };\n\n  exports[methodName].displayName = 'icepick.' + methodName;\n});\n\nexports.extend = exports.assign = function assign(obj) {\n  for (var _len2 = arguments.length, objs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    objs[_key2 - 1] = arguments[_key2];\n  }\n\n  const newObj = objs.reduce(singleAssign, obj);\n  return _freeze(newObj);\n};\n\nfunction singleAssign(obj1, obj2) {\n  return Object.keys(obj2).reduce((obj, key) => {\n    return i.assoc(obj, key, obj2[key]);\n  }, obj1);\n}\n\nexports.merge = merge;\n\nfunction merge(target, source, resolver) {\n  if (target == null || source == null) {\n    return target;\n  }\n\n  return Object.keys(source).reduce((obj, key) => {\n    const sourceVal = source[key];\n    const targetVal = obj[key];\n    const resolvedSourceVal = resolver ? resolver(targetVal, sourceVal, key) : sourceVal;\n\n    if (weCareAbout(sourceVal) && weCareAbout(targetVal)) {\n      // if they are both frozen and reference equal, assume they are deep equal\n      if (resolvedSourceVal === targetVal && (process.env.NODE_ENV === 'production' || Object.isFrozen(resolvedSourceVal) && Object.isFrozen(targetVal))) {\n        return obj;\n      }\n\n      if (Array.isArray(sourceVal)) {\n        return i.assoc(obj, key, resolvedSourceVal);\n      } // recursively merge pairs of objects\n\n\n      return assocIfDifferent(obj, key, merge(targetVal, resolvedSourceVal, resolver));\n    } // primitive values, stuff with prototypes\n\n\n    return assocIfDifferent(obj, key, resolvedSourceVal);\n  }, target);\n}\n\nfunction assocIfDifferent(target, key, value) {\n  if (target[key] === value) {\n    return target;\n  }\n\n  return i.assoc(target, key, value);\n}\n\nconst chainProto = {\n  value: function value() {\n    return this.val;\n  },\n  thru: function thru(fn) {\n    this.val = freezeIfNeeded(fn(this.val));\n    return this;\n  }\n};\nObject.keys(exports).forEach(methodName => {\n  if (methodName.match(/^(map|filter)$/)) {\n    chainProto[methodName] = function (fn) {\n      this.val = exports[methodName](fn, this.val);\n      return this;\n    };\n\n    return;\n  }\n\n  chainProto[methodName] = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    this.val = exports[methodName](this.val, ...args);\n    return this;\n  };\n});\n\nexports.chain = function chain(val) {\n  const wrapped = Object.create(chainProto);\n  wrapped.val = val;\n  return wrapped;\n}; // for testing\n\n\nif (process.env.NODE_ENV !== 'development' && process.env.NODE_ENV !== 'production') {\n  exports._weCareAbout = weCareAbout;\n}","map":{"version":3,"sources":["/Users/massimilianoalbini/Documents/gain-drop/node_modules/icepick/icepick.js"],"names":["i","exports","identity","coll","weCareAbout","val","Array","isArray","isObjectLike","constructor","Object","getPrototypeOf","prototype","forKeys","obj","iter","idx","keys","length","cloneObj","newObj","create","key","clone","slice","freezeIfNeeded","process","env","NODE_ENV","isFrozen","baseFreeze","_freeze","freeze","prevNodes","some","Error","push","prop","pop","thaw","newColl","assoc","value","set","dissoc","unset","assocIn","path","key0","setIn","dissocIn","hasOwnProperty","unsetIn","baseGet","reduce","curr","getIn","updateIn","callback","existingVal","forEach","methodName","arr","newArr","displayName","splice","_args","args","map","apply","arg1","arg2","fn","extend","assign","objs","singleAssign","obj1","obj2","merge","target","source","resolver","sourceVal","targetVal","resolvedSourceVal","assocIfDifferent","chainProto","thru","match","chain","wrapped","_weCareAbout"],"mappings":"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","sourcesContent":["/**\n * This allows you to work with object hierarchies that have been frozen\n * with Object.freeze().  \"get\" operations can use the normal JS syntax,\n * but operations that modify the data will have to return partial copies of\n * the structure. The portions of the structure that did not change will\n * === their previous values.\n *\n * Inspired by clojure/mori and Immutable.js\n */\n\n'use strict'\n\nconst i = exports\n\nconst identity = coll => coll\n\n// we only care about objects or arrays for now\nconst weCareAbout = val => val !== null &&\n    (Array.isArray(val) ||\n      // This will skip objects created with `new Foo()`\n      // and objects created with `Object.create(proto)`\n      // The benefit is ignoring DOM elements and event emitters,\n      // which are often circular.\n      isObjectLike(val))\n\nconst isObjectLike = val => typeof val === 'object' &&\n    (val.constructor === Object ||\n      val.constructor == null) &&\n    (Object.getPrototypeOf(val) === Object.prototype ||\n      Object.getPrototypeOf(val) === null)\n\nconst forKeys = (obj, iter) => {\n  let idx, keys\n  if (Array.isArray(obj)) {\n    idx = obj.length\n    while (idx--) {\n      iter(idx)\n    }\n    return\n  }\n  keys = Object.keys(obj)\n  idx = keys.length\n  while (idx--) {\n    iter(keys[idx])\n  }\n}\n\nconst cloneObj = obj => {\n  const newObj = obj.constructor == null ? Object.create(null) : {}\n  const keys = Object.keys(obj)\n  let idx = keys.length\n  let key\n  while (idx--) {\n    key = keys[idx]\n    newObj[key] = obj[key]\n  }\n  return newObj\n}\n\nconst clone = (coll) => {\n  if (Array.isArray(coll)) {\n    return coll.slice()\n  } else {\n    return cloneObj(coll)\n  }\n}\n\nconst freezeIfNeeded = process.env.NODE_ENV === 'production'\n? identity\n: coll => {\n  if (weCareAbout(coll) && !Object.isFrozen(coll)) {\n    return baseFreeze(coll)\n  }\n  return coll\n}\n\nconst _freeze = process.env.NODE_ENV === 'production'\n? identity\n: coll => {\n  if (typeof coll === 'object') {\n    return Object.freeze(coll)\n  } else {\n    return coll\n  }\n}\n\nconst prevNodes = []\n\nconst baseFreeze = (coll) => {\n  if (prevNodes.some(val => val === coll)) {\n    throw new Error('object has a reference cycle')\n  }\n  prevNodes.push(coll)\n  forKeys(coll, key => {\n    const prop = coll[key]\n    if (weCareAbout(prop)) {\n      baseFreeze(prop)\n    }\n  })\n  prevNodes.pop()\n\n  Object.freeze(coll)\n  return coll\n}\n\n/**\n * recrursively freeze an object and all its child objects\n * @param  {Object|Array} coll\n * @return {Object|Array}\n */\nexports.freeze = process.env.NODE_ENV === 'production'\n? identity\n: baseFreeze\n\n/**\n * recursively un-freeze an object, by cloning frozen collections\n * @param  {[type]} coll [description]\n * @return {[type]}      [description]\n */\nexports.thaw = function thaw (coll) {\n  if (!weCareAbout(coll) || !Object.isFrozen(coll)) return coll\n\n  const newColl = Array.isArray(coll)\n    ? new Array(coll.length)\n    : {}\n\n  forKeys(coll, key => {\n    newColl[key] = thaw(coll[key])\n  })\n  return newColl\n}\n\n/**\n * set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key   Key or index\n * @param  {Object}        value\n * @return {Object|Array}        new object hierarchy with modifications\n */\nexports.assoc = function assoc (coll, key, value) {\n  if (coll[key] === value) {\n    return _freeze(coll)\n  }\n\n  const newObj = clone(coll)\n\n  newObj[key] = freezeIfNeeded(value)\n\n  return _freeze(newObj)\n}\nexports.set = exports.assoc\n\n/**\n * un-set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {String|Number} key  Key or Index\n * @return {Object|Array}       New object or array\n */\nexports.dissoc = function dissoc (coll, key) {\n  const newObj = clone(coll)\n\n  delete newObj[key]\n\n  return _freeze(newObj)\n}\nexports.unset = exports.dissoc\n\n/**\n * set a value deep in a hierarchical structure\n * @param  {Object|Array} coll\n * @param  {Array}        path    A list of keys to traverse\n * @param  {Object}       value\n * @return {Object|Array}       new object hierarchy with modifications\n */\nexports.assocIn = function assocIn (coll, path, value) {\n  const key0 = path[0]\n  if (path.length === 1) {\n    // simplest case is a 1-element array.  Just a simple assoc.\n    return i.assoc(coll, key0, value)\n  } else {\n    // break the problem down.  Assoc this object with the first key\n    // and the result of assocIn with the rest of the keys\n    return i.assoc(coll, key0, assocIn(coll[key0] || {}, path.slice(1), value))\n  }\n}\nexports.setIn = exports.assocIn\n\n/**\n * un-set a value on an object or array\n * @param  {Object|Array}  coll\n * @param  {Array} path  A list of keys to traverse\n * @return {Object|Array}       New object or array\n */\nexports.dissocIn = function dissocIn (coll, path) {\n  const key0 = path[0]\n  if (!coll.hasOwnProperty(key0)) {\n    return coll\n  }\n  if (path.length === 1) {\n    // simplest case is a 1-element array.  Just a simple dissoc.\n    return i.dissoc(coll, key0)\n  } else {\n    // break the problem down.  Assoc this object with the first key\n    // and the result of dissocIn with the rest of the keys\n    return i.assoc(coll, key0, dissocIn(coll[key0], path.slice(1)))\n  }\n}\nexports.unsetIn = exports.dissocIn\n\n/**\n * get an object from a hierachy based on an array of keys\n * @param  {Object|Array} coll\n * @param  {Array}        path    list of keys\n * @return {Object}       value, or undefined\n */\nfunction baseGet (coll, path) {\n  return (path || []).reduce((curr, key) => {\n    if (!curr) { return }\n    return curr[key]\n  }, coll)\n}\n\nexports.getIn = baseGet\n\n/**\n * Update a value in a hierarchy\n * @param  {Object|Array}   coll\n * @param  {Array}          path     list of keys\n * @param  {Function} callback The existing value with be passed to this.\n *                             Return the new value to set\n * @return {Object|Array}      new object hierarchy with modifications\n */\nexports.updateIn = function updateIn (coll, path, callback) {\n  const existingVal = baseGet(coll, path)\n  return i.assocIn(coll, path, callback(existingVal))\n};\n\n// generate wrappers for the mutative array methods\n['push', 'unshift', 'pop', 'shift', 'reverse', 'sort']\n.forEach((methodName) => {\n  exports[methodName] = function (arr, val) {\n    const newArr = [...arr]\n\n    newArr[methodName](freezeIfNeeded(val))\n\n    return _freeze(newArr)\n  }\n\n  exports[methodName].displayName = 'icepick.' + methodName\n})\n\n// splice is special because it is variadic\nexports.splice = function splice (arr, ..._args) {\n  const newArr = [...arr]\n  const args = _args.map(freezeIfNeeded)\n\n  newArr.splice.apply(newArr, args)\n\n  return _freeze(newArr)\n}\n\n// slice is non-mutative\nexports.slice = function slice (arr, arg1, arg2) {\n  const newArr = arr.slice(arg1, arg2)\n\n  return _freeze(newArr)\n};\n\n['map', 'filter'].forEach((methodName) => {\n  exports[methodName] = function (fn, arr) {\n    const newArr = arr[methodName](fn)\n\n    return _freeze(newArr)\n  }\n\n  exports[methodName].displayName = 'icepick.' + methodName\n})\n\nexports.extend =\nexports.assign = function assign (obj, ...objs) {\n  const newObj = objs.reduce(singleAssign, obj)\n\n  return _freeze(newObj)\n}\n\nfunction singleAssign (obj1, obj2) {\n  return Object.keys(obj2).reduce((obj, key) => {\n    return i.assoc(obj, key, obj2[key])\n  }, obj1)\n}\n\nexports.merge = merge\nfunction merge (target, source, resolver) {\n  if (target == null || source == null) {\n    return target\n  }\n  return Object.keys(source).reduce((obj, key) => {\n    const sourceVal = source[key]\n    const targetVal = obj[key]\n\n    const resolvedSourceVal =\n      resolver ? resolver(targetVal, sourceVal, key) : sourceVal\n\n    if (weCareAbout(sourceVal) && weCareAbout(targetVal)) {\n      // if they are both frozen and reference equal, assume they are deep equal\n      if (\n        resolvedSourceVal === targetVal &&\n        (\n          process.env.NODE_ENV === 'production' ||\n          (\n            Object.isFrozen(resolvedSourceVal) &&\n            Object.isFrozen(targetVal)\n          )\n        )\n      ) {\n        return obj\n      }\n      if (Array.isArray(sourceVal)) {\n        return i.assoc(obj, key, resolvedSourceVal)\n      }\n      // recursively merge pairs of objects\n      return assocIfDifferent(obj, key,\n        merge(targetVal, resolvedSourceVal, resolver))\n    }\n\n    // primitive values, stuff with prototypes\n    return assocIfDifferent(obj, key, resolvedSourceVal)\n  }, target)\n}\n\nfunction assocIfDifferent (target, key, value) {\n  if (target[key] === value) {\n    return target\n  }\n  return i.assoc(target, key, value)\n}\n\nconst chainProto = {\n  value: function value () {\n    return this.val\n  },\n  thru: function thru (fn) {\n    this.val = freezeIfNeeded(fn(this.val))\n    return this\n  }\n}\n\nObject.keys(exports).forEach((methodName) => {\n  if (methodName.match(/^(map|filter)$/)) {\n    chainProto[methodName] = function (fn) {\n      this.val = exports[methodName](fn, this.val)\n      return this\n    }\n    return\n  }\n  chainProto[methodName] = function (...args) {\n    this.val = exports[methodName](this.val, ...args)\n    return this\n  }\n})\n\nexports.chain = function chain (val) {\n  const wrapped = Object.create(chainProto)\n  wrapped.val = val\n  return wrapped\n}\n\n// for testing\nif (process.env.NODE_ENV !== 'development' &&\n  process.env.NODE_ENV !== 'production') {\n  exports._weCareAbout = weCareAbout\n}\n"]},"metadata":{},"sourceType":"script"}