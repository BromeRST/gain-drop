{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst cbor_1 = require(\"./cbor\");\n\nclass FountainEncoderPart {\n  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  get seqNum() {\n    return this._seqNum;\n  }\n\n  get seqLength() {\n    return this._seqLength;\n  }\n\n  get checksum() {\n    return this._checksum;\n  }\n\n  cbor() {\n    const result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n    return Buffer.from(result);\n  }\n\n  description() {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n  }\n\n  static fromCBOR(cborPayload) {\n    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);\n    assert_1.default(typeof seqNum === 'number');\n    assert_1.default(typeof seqLength === 'number');\n    assert_1.default(typeof messageLength === 'number');\n    assert_1.default(typeof checksum === 'number');\n    assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n  }\n\n}\n\nexports.FountainEncoderPart = FountainEncoderPart;\n\nclass FountainEncoder {\n  constructor(message) {\n    let maxFragmentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let firstSeqNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let minFragmentLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n\n  get fragmentsLength() {\n    return this._fragments.length;\n  }\n\n  get fragments() {\n    return this._fragments;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  isComplete() {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  isSinglePart() {\n    return this._fragments.length === 1;\n  }\n\n  seqLength() {\n    return this._fragments.length;\n  }\n\n  mix(indexes) {\n    return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n  }\n\n  nextPart() {\n    this.seqNum = utils_1.toUint32(this.seqNum + 1);\n    const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n  }\n\n  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n    assert_1.default(messageLength > 0);\n    assert_1.default(minFragmentLength > 0);\n    assert_1.default(maxFragmentLength >= minFragmentLength);\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  static partitionMessage(message, fragmentLength) {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n      fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n      .fill(fragment, 0, fragment.length);\n\n      _fragments.push(fragment);\n    }\n\n    return _fragments;\n  }\n\n}\n\nexports.default = FountainEncoder;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA,MAAaA,mBAAb,CAAgC;AAC9BC,cACUC,OADV,EAEUC,UAFV,EAGUC,cAHV,EAIUC,SAJV,EAKUC,SALV,EAK2B;AAJjB;AACA;AACA;AACA;AACA;AACL;;AAEY,MAAbC,aAAa;AAAK,WAAO,KAAKH,cAAZ;AAA6B;;AACvC,MAARI,QAAQ;AAAK,WAAO,KAAKF,SAAZ;AAAwB;;AAC/B,MAANG,MAAM;AAAK,WAAO,KAAKP,OAAZ;AAAsB;;AACxB,MAATQ,SAAS;AAAK,WAAO,KAAKP,UAAZ;AAAyB;;AAC/B,MAARQ,QAAQ;AAAK,WAAO,KAAKN,SAAZ;AAAwB;;AAElCO,MAAI;AACT,UAAMC,MAAM,GAAGC,kBAAW,CACxB,KAAKZ,OADmB,EAExB,KAAKC,UAFmB,EAGxB,KAAKC,cAHmB,EAIxB,KAAKC,SAJmB,EAKxB,KAAKC,SALmB,CAAX,CAAf;AAQA,WAAOS,MAAM,CAACC,IAAP,CAAYH,MAAZ,CAAP;AACD;;AAEMI,aAAW;AAChB,WAAO,UAAU,KAAKf,OAAO,YAAY,KAAKC,UAAU,gBAAgB,KAAKC,cAAc,cAAc,KAAKC,SAAS,UAAU,KAAKC,SAAL,CAAeY,QAAf,CAAwB,KAAxB,CAA8B,EAA/J;AACD;;AAEqB,SAARC,QAAQ,CAACC,WAAD,EAA6B;AACjD,UAAM,CACJX,MADI,EAEJC,SAFI,EAGJH,aAHI,EAIJI,QAJI,EAKJH,QALI,IAMFM,kBAAWM,WAAX,CANJ;AAQAC,qBAAO,OAAOZ,MAAP,KAAkB,QAAzB;AACAY,qBAAO,OAAOX,SAAP,KAAqB,QAA5B;AACAW,qBAAO,OAAOd,aAAP,KAAyB,QAAhC;AACAc,qBAAO,OAAOV,QAAP,KAAoB,QAA3B;AACAU,qBAAON,MAAM,CAACO,QAAP,CAAgBd,QAAhB,KAA6BA,QAAQ,CAACe,MAAT,GAAkB,CAAtD;AAEA,WAAO,IAAIvB,mBAAJ,CACLS,MADK,EAELC,SAFK,EAGLH,aAHK,EAILI,QAJK,EAKLI,MAAM,CAACC,IAAP,CAAYR,QAAZ,CALK,CAAP;AAOD;;AArD6B;;AAAhCgB;;AAwDA,MAAqBC,eAArB,CAAoC;AAOlCxB,cACEyB,OADF,EAIgC;AAAA,QAF9BC,iBAE8B,uEAFF,GAEE;AAAA,QAD9BC,WAC8B,uEADR,CACQ;AAAA,QAA9BC,iBAA8B,uEAAF,EAAE;AAE9B,UAAMC,cAAc,GAAGL,eAAe,CAACM,yBAAhB,CAA0CL,OAAO,CAACH,MAAlD,EAA0DM,iBAA1D,EAA6EF,iBAA7E,CAAvB;AAEA,SAAKvB,cAAL,GAAsBsB,OAAO,CAACH,MAA9B;AACA,SAAKS,UAAL,GAAkBP,eAAe,CAACQ,gBAAhB,CAAiCP,OAAjC,EAA0CI,cAA1C,CAAlB;AACA,SAAKA,cAAL,GAAsBA,cAAtB;AACA,SAAKrB,MAAL,GAAcyB,iBAASN,WAAT,CAAd;AACA,SAAKjB,QAAL,GAAgBuB,eAAOR,OAAP,CAAhB;AACD;;AAEyB,MAAfS,eAAe;AAAK,WAAO,KAAKH,UAAL,CAAgBT,MAAvB;AAAgC;;AAC3C,MAATa,SAAS;AAAK,WAAO,KAAKJ,UAAZ;AAAyB;;AAC1B,MAAbzB,aAAa;AAAK,WAAO,KAAKH,cAAZ;AAA6B;;AAEnDiC,YAAU;AACf,WAAO,KAAK5B,MAAL,IAAe,KAAKuB,UAAL,CAAgBT,MAAtC;AACD;;AAEMe,cAAY;AACjB,WAAO,KAAKN,UAAL,CAAgBT,MAAhB,KAA2B,CAAlC;AACD;;AAEMb,WAAS;AACd,WAAO,KAAKsB,UAAL,CAAgBT,MAAvB;AACD;;AAEMgB,KAAG,CAACC,OAAD,EAAkB;AAC1B,WAAOA,OAAO,CAACC,MAAR,CACL,CAAC5B,MAAD,EAAS6B,KAAT,KAAmBR,kBAAU,KAAKF,UAAL,CAAgBU,KAAhB,CAAV,EAAkC7B,MAAlC,CADd,EAELE,MAAM,CAAC4B,KAAP,CAAa,KAAKb,cAAlB,EAAkC,CAAlC,CAFK,CAAP;AAID;;AAEMc,UAAQ;AACb,SAAKnC,MAAL,GAAcyB,iBAAS,KAAKzB,MAAL,GAAc,CAAvB,CAAd;AAEA,UAAM+B,OAAO,GAAGK,gCAAgB,KAAKpC,MAArB,EAA6B,KAAKuB,UAAL,CAAgBT,MAA7C,EAAqD,KAAKZ,QAA1D,CAAhB;AACA,UAAMmC,KAAK,GAAG,KAAKP,GAAL,CAASC,OAAT,CAAd;AAEA,WAAO,IAAIxC,mBAAJ,CACL,KAAKS,MADA,EAEL,KAAKuB,UAAL,CAAgBT,MAFX,EAGL,KAAKnB,cAHA,EAIL,KAAKO,QAJA,EAKLmC,KALK,CAAP;AAOD;;AAEsC,SAAzBf,yBAAyB,CACrCxB,aADqC,EAErCsB,iBAFqC,EAGrCF,iBAHqC,EAGZ;AAEzBN,qBAAOd,aAAa,GAAG,CAAvB;AACAc,qBAAOQ,iBAAiB,GAAG,CAA3B;AACAR,qBAAOM,iBAAiB,IAAIE,iBAA5B;AAEA,UAAMkB,gBAAgB,GAAGC,IAAI,CAACC,IAAL,CAAU1C,aAAa,GAAGsB,iBAA1B,CAAzB;AACA,QAAIC,cAAc,GAAG,CAArB;;AAEA,SAAK,IAAIoB,aAAa,GAAG,CAAzB,EAA4BA,aAAa,IAAIH,gBAA7C,EAA+DG,aAAa,EAA5E,EAAgF;AAC9EpB,oBAAc,GAAGkB,IAAI,CAACC,IAAL,CAAU1C,aAAa,GAAG2C,aAA1B,CAAjB;;AAEA,UAAIpB,cAAc,IAAIH,iBAAtB,EAAyC;AACvC;AACD;AACF;;AAED,WAAOG,cAAP;AACD;;AAE6B,SAAhBG,gBAAgB,CAACP,OAAD,EAAkBI,cAAlB,EAAwC;AACpE,QAAIqB,SAAS,GAAGpC,MAAM,CAACC,IAAP,CAAYU,OAAZ,CAAhB;AACA,QAAIlB,QAAJ;AACA,QAAIwB,UAAU,GAAa,EAA3B;;AAEA,WAAOmB,SAAS,CAAC5B,MAAV,GAAmB,CAA1B,EAA6B;AAC3B,OAACf,QAAD,EAAW2C,SAAX,IAAwBjB,cAAMiB,SAAN,EAAiB,CAACrB,cAAlB,CAAxB;AACAtB,cAAQ,GAAGO,MAAM,CACd4B,KADQ,CACFb,cADE,EACc,CADd,EACiB;AADjB,OAERsB,IAFQ,CAEH5C,QAFG,EAEO,CAFP,EAEUA,QAAQ,CAACe,MAFnB,CAAX;;AAGAS,gBAAU,CAACqB,IAAX,CAAgB7C,QAAhB;AACD;;AAED,WAAOwB,UAAP;AACD;;AAjGiC;;AAApCR","names":["FountainEncoderPart","constructor","_seqNum","_seqLength","_messageLength","_checksum","_fragment","messageLength","fragment","seqNum","seqLength","checksum","cbor","result","cbor_1","Buffer","from","description","toString","fromCBOR","cborPayload","assert_1","isBuffer","length","exports","FountainEncoder","message","maxFragmentLength","firstSeqNum","minFragmentLength","fragmentLength","findNominalFragmentLength","_fragments","partitionMessage","utils_1","fragmentsLength","fragments","isComplete","isSinglePart","mix","indexes","reduce","index","alloc","nextPart","fountainUtils_1","mixed","maxFragmentCount","Math","ceil","fragmentCount","remaining","fill","push"],"sourceRoot":"","sources":["../src/fountainEncoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}