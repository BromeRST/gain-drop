{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n\n(function (STYLES) {\n  STYLES[\"STANDARD\"] = \"standard\";\n  STYLES[\"URI\"] = \"uri\";\n  STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\n\nconst getWord = index => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);\n};\n\nconst getMinimalWord = index => {\n  const byteword = getWord(index);\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;\n};\n\nconst addCRC = string => {\n  const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n  return `${string}${crc}`;\n};\n\nconst encodeWithSeparator = (word, separator) => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => [...result, getWord(w)], []);\n  return result.join(separator);\n};\n\nconst encodeMinimal = word => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n  return result;\n};\n\nconst decodeWord = (word, wordLength) => {\n  assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n  const dim = 26; // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);\n\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  } // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n\n\n  let x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n  assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table'); // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value);\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n    assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  } // Successful decode.\n\n\n  return Buffer.from([value]).toString('hex');\n};\n\nconst _decode = (string, separator, wordLength) => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n  const decodedString = words.map(word => decodeWord(word, wordLength)).join('');\n  assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n  const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);\n  const checksum = utils_1.getCRCHex(body); // convert to hex\n\n  assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n  return body.toString('hex');\n};\n\nconst decode = function (string) {\n  let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STYLES.MINIMAL;\n\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\n\nconst encode = function (string) {\n  let style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STYLES.MINIMAL;\n\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\n\nexports.default = {\n  decode,\n  encode,\n  STYLES\n};","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA;;AACA;;AAEA,MAAMA,SAAS,GAAG,kgCAAlB;AACA,IAAIC,oBAAoB,GAAa,EAArC;AACA,MAAMC,aAAa,GAAG,GAAtB;AACA,MAAMC,eAAe,GAAG,CAAxB;AACA,MAAMC,uBAAuB,GAAG,CAAhC;AAEA,IAAKC,MAAL;;AAAA,WAAKA,MAAL,EAAW;AACTA;AACAA;AACAA;AACD,CAJD,EAAKA,MAAM,KAANA,MAAM,MAAX;;AAMA,MAAMC,OAAO,GAAIC,KAAD,IAA0B;AACxC,SAAOP,SAAS,CAACQ,KAAV,CAAgBD,KAAK,GAAGJ,eAAxB,EAA0CI,KAAK,GAAGJ,eAAT,GAA4BA,eAArE,CAAP;AACD,CAFD;;AAIA,MAAMM,cAAc,GAAIF,KAAD,IAA0B;AAC/C,QAAMG,QAAQ,GAAGJ,OAAO,CAACC,KAAD,CAAxB;AAEA,SAAO,GAAGG,QAAQ,CAAC,CAAD,CAAG,GAAGA,QAAQ,CAACP,eAAe,GAAG,CAAnB,CAAqB,EAArD;AACD,CAJD;;AAMA,MAAMQ,MAAM,GAAIC,MAAD,IAA2B;AACxC,QAAMC,GAAG,GAAGC,kBAAUC,MAAM,CAACC,IAAP,CAAYJ,MAAZ,EAAoB,KAApB,CAAV,CAAZ;AAEA,SAAO,GAAGA,MAAM,GAAGC,GAAG,EAAtB;AACD,CAJD;;AAMA,MAAMI,mBAAmB,GAAG,CAACC,IAAD,EAAeC,SAAf,KAA4C;AACtE,QAAMC,eAAe,GAAGT,MAAM,CAACO,IAAD,CAA9B;AACA,QAAMG,WAAW,GAAGN,MAAM,CAACC,IAAP,CAAYI,eAAZ,EAA6B,KAA7B,CAApB;AACA,QAAME,MAAM,GAAGD,WAAW,CAACE,MAAZ,CAAmB,CAACD,MAAD,EAAmBE,CAAnB,KAA0B,CAAC,GAAGF,MAAJ,EAAYhB,OAAO,CAACkB,CAAD,CAAnB,CAA7C,EAAuE,EAAvE,CAAf;AAEA,SAAOF,MAAM,CAACG,IAAP,CAAYN,SAAZ,CAAP;AACD,CAND;;AAQA,MAAMO,aAAa,GAAIR,IAAD,IAAyB;AAC7C,QAAME,eAAe,GAAGT,MAAM,CAACO,IAAD,CAA9B;AACA,QAAMG,WAAW,GAAGN,MAAM,CAACC,IAAP,CAAYI,eAAZ,EAA6B,KAA7B,CAApB;AACA,QAAME,MAAM,GAAGD,WAAW,CAACE,MAAZ,CAAmB,CAACD,MAAD,EAASE,CAAT,KAAeF,MAAM,GAAGb,cAAc,CAACe,CAAD,CAAzD,EAA8D,EAA9D,CAAf;AAEA,SAAOF,MAAP;AACD,CAND;;AAQA,MAAMK,UAAU,GAAG,CAACT,IAAD,EAAeU,UAAf,KAA6C;AAC9DC,mBAAOX,IAAI,CAACY,MAAL,KAAgBF,UAAvB,EAAmC,mEAAnC;AAEA,QAAMG,GAAG,GAAG,EAAZ,CAH8D,CAK9D;AACA;AACA;;AACA,MAAI9B,oBAAoB,CAAC6B,MAArB,KAAgC,CAApC,EAAuC;AACrC,UAAME,SAAS,GAAGD,GAAG,GAAGA,GAAxB;AACA9B,wBAAoB,GAAG,CAAC,GAAG,IAAIgC,KAAJ,CAAUD,SAAV,CAAJ,EAA0BE,GAA1B,CAA8B,MAAM,CAAC,CAArC,CAAvB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,aAApB,EAAmCiC,CAAC,EAApC,EAAwC;AACtC,YAAMzB,QAAQ,GAAGJ,OAAO,CAAC6B,CAAD,CAAxB;AACA,UAAIC,CAAC,GAAG1B,QAAQ,CAAC,CAAD,CAAR,CAAY2B,UAAZ,CAAuB,CAAvB,IAA4B,IAAIA,UAAJ,CAAe,CAAf,CAApC;AACA,UAAIC,CAAC,GAAG5B,QAAQ,CAAC,CAAD,CAAR,CAAY2B,UAAZ,CAAuB,CAAvB,IAA4B,IAAIA,UAAJ,CAAe,CAAf,CAApC;AACA,UAAIE,MAAM,GAAGD,CAAC,GAAGP,GAAJ,GAAUK,CAAvB;AACAnC,0BAAoB,CAACsC,MAAD,CAApB,GAA+BJ,CAA/B;AACD;AACF,GAnB6D,CAqB9D;AACA;;;AACA,MAAIC,CAAC,GAAIlB,IAAI,CAAC,CAAD,CAAL,CAAUsB,WAAV,GAAwBH,UAAxB,CAAmC,CAAnC,IAAwC,IAAIA,UAAJ,CAAe,CAAf,CAAhD;AACA,MAAIC,CAAC,GAAIpB,IAAI,CAACU,UAAU,IAAI,CAAd,GAAkB,CAAlB,GAAsB,CAAvB,CAAL,CAAgCY,WAAhC,GAA8CH,UAA9C,CAAyD,CAAzD,IAA8D,IAAIA,UAAJ,CAAe,CAAf,CAAtE;AAEAR,mBAAO,KAAKO,CAAL,IAAUA,CAAC,GAAGL,GAAd,IAAqB,KAAKO,CAA1B,IAA+BA,CAAC,GAAGP,GAA1C,EAA+C,iCAA/C;AAEA,MAAIQ,MAAM,GAAGD,CAAC,GAAGP,GAAJ,GAAUK,CAAvB;AACA,MAAIK,KAAK,GAAGxC,oBAAoB,CAACsC,MAAD,CAAhC;AAEAV,mBAAOY,KAAK,KAAK,CAAC,CAAlB,EAAqB,8CAArB,EA/B8D,CAiC9D;;AACA,MAAIb,UAAU,IAAIzB,eAAlB,EAAmC;AACjC,UAAMO,QAAQ,GAAGJ,OAAO,CAACmC,KAAD,CAAxB;AACA,QAAIC,EAAE,GAAGxB,IAAI,CAAC,CAAD,CAAJ,CAAQsB,WAAR,EAAT;AACA,QAAIG,EAAE,GAAGzB,IAAI,CAAC,CAAD,CAAJ,CAAQsB,WAAR,EAAT;AAEAX,qBAAOa,EAAE,KAAKhC,QAAQ,CAAC,CAAD,CAAf,IAAsBiC,EAAE,KAAKjC,QAAQ,CAAC,CAAD,CAA5C,EAAiD,mDAAjD;AACD,GAxC6D,CA0C9D;;;AACA,SAAOK,MAAM,CAACC,IAAP,CAAY,CAACyB,KAAD,CAAZ,EAAqBG,QAArB,CAA8B,KAA9B,CAAP;AACD,CA5CD;;AA8CA,MAAMC,OAAO,GAAG,CAACjC,MAAD,EAAiBO,SAAjB,EAAoCS,UAApC,KAAkE;AAChF,QAAMkB,KAAK,GAAGlB,UAAU,IAAIzB,eAAd,GAAgCS,MAAM,CAACmC,KAAP,CAAa5B,SAAb,CAAhC,GAA0DL,kBAAUF,MAAV,EAAkB,CAAlB,CAAxE;AACA,QAAMoC,aAAa,GAAGF,KAAK,CAACZ,GAAN,CAAWhB,IAAD,IAAkBS,UAAU,CAACT,IAAD,EAAOU,UAAP,CAAtC,EAA0DH,IAA1D,CAA+D,EAA/D,CAAtB;AAEAI,mBAAOmB,aAAa,CAAClB,MAAd,IAAwB,CAA/B,EAAkC,kDAAlC;AAEA,QAAM,CAACmB,IAAD,EAAOC,YAAP,IAAuBpC,cAAMC,MAAM,CAACC,IAAP,CAAYgC,aAAZ,EAA2B,KAA3B,CAAN,EAAyC,CAAzC,CAA7B;AACA,QAAMG,QAAQ,GAAGrC,kBAAUmC,IAAV,CAAjB,CAPgF,CAOhD;;AAEhCpB,mBAAOsB,QAAQ,KAAKD,YAAY,CAACN,QAAb,CAAsB,KAAtB,CAApB,EAAkD,kBAAlD;AAEA,SAAOK,IAAI,CAACL,QAAL,CAAc,KAAd,CAAP;AACD,CAZD;;AAeA,MAAMQ,MAAM,GAAG,UAACxC,MAAD,EAA2D;AAAA,MAA1CyC,KAA0C,uEAA1BhD,MAAM,CAACiD,OAAmB;;AACxE,UAAQD,KAAR;AACE,SAAKhD,MAAM,CAACkD,QAAZ;AACE,aAAOV,OAAO,CAACjC,MAAD,EAAS,GAAT,EAAcT,eAAd,CAAd;;AACF,SAAKE,MAAM,CAACmD,GAAZ;AACE,aAAOX,OAAO,CAACjC,MAAD,EAAS,GAAT,EAAcT,eAAd,CAAd;;AACF,SAAKE,MAAM,CAACiD,OAAZ;AACE,aAAOT,OAAO,CAACjC,MAAD,EAAS,EAAT,EAAaR,uBAAb,CAAd;;AACF;AACE,YAAM,IAAIqD,KAAJ,CAAU,iBAAiBJ,KAAK,EAAhC,CAAN;AARJ;AAUD,CAXD;;AAaA,MAAMK,MAAM,GAAG,UAAC9C,MAAD,EAA2D;AAAA,MAA1CyC,KAA0C,uEAA1BhD,MAAM,CAACiD,OAAmB;;AACxE,UAAQD,KAAR;AACE,SAAKhD,MAAM,CAACkD,QAAZ;AACE,aAAOtC,mBAAmB,CAACL,MAAD,EAAS,GAAT,CAA1B;;AACF,SAAKP,MAAM,CAACmD,GAAZ;AACE,aAAOvC,mBAAmB,CAACL,MAAD,EAAS,GAAT,CAA1B;;AACF,SAAKP,MAAM,CAACiD,OAAZ;AACE,aAAO5B,aAAa,CAACd,MAAD,CAApB;;AACF;AACE,YAAM,IAAI6C,KAAJ,CAAU,iBAAiBJ,KAAK,EAAhC,CAAN;AARJ;AAUD,CAXD;;AAaAM,kBAAe;AACbP,QADa;AAEbM,QAFa;AAGbrD;AAHa,CAAf","names":["bytewords","bytewordsLookUpTable","BYTEWORDS_NUM","BYTEWORD_LENGTH","MINIMAL_BYTEWORD_LENGTH","STYLES","getWord","index","slice","getMinimalWord","byteword","addCRC","string","crc","utils_1","Buffer","from","encodeWithSeparator","word","separator","crcAppendedWord","crcWordBuff","result","reduce","w","join","encodeMinimal","decodeWord","wordLength","assert_1","length","dim","array_len","Array","map","i","x","charCodeAt","y","offset","toLowerCase","value","c1","c2","toString","_decode","words","split","decodedString","body","bodyChecksum","checksum","decode","style","MINIMAL","STANDARD","URI","Error","encode","exports"],"sourceRoot":"","sources":["../src/bytewords.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}