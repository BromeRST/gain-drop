{"ast":null,"code":"/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables';\nimport pRetry, { AbortError } from 'p-retry';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport * as Token from './token.js';\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\nconst MAX_STORE_RETRIES = 5;\nconst MAX_CONCURRENT_UPLOADS = 3;\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 10; // chunk to ~10MB CARs\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements Service\n */\n\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?:URL}} options\n   */\n  constructor(_ref) {\n    let {\n      token,\n      endpoint = new URL('https://api.nft.storage')\n    } = _ref;\n\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n\n    this.endpoint = endpoint;\n  }\n  /**\n   * @hidden\n   * @param {string} token\n   */\n\n\n  static auth(token) {\n    if (!token) throw new Error('missing token');\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js'\n    };\n  }\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @returns {Promise<CIDString>}\n   */\n\n\n  static async storeBlob(service, blob) {\n    const blockstore = new Blockstore();\n    let cidString;\n\n    try {\n      const {\n        cid,\n        car\n      } = await NFTStorage.encodeBlob(blob, {\n        blockstore\n      });\n      await NFTStorage.storeCar(service, car);\n      cidString = cid.toString();\n    } finally {\n      await blockstore.close();\n    }\n\n    return cidString;\n  }\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n\n\n  static async storeCar(_ref2, car) {\n    let {\n      endpoint,\n      token\n    } = _ref2;\n    let {\n      onStoredChunk,\n      maxRetries,\n      decoders\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const url = new URL('upload/', endpoint);\n    const headers = NFTStorage.auth(token);\n    const targetSize = MAX_CHUNK_SIZE;\n    const splitter = car instanceof Blob ? await TreewalkCarSplitter.fromBlob(car, targetSize, {\n      decoders\n    }) : new TreewalkCarSplitter(car, targetSize, {\n      decoders\n    });\n    const upload = transform(MAX_CONCURRENT_UPLOADS, async function (\n    /** @type {AsyncIterable<Uint8Array>} */\n    car) {\n      const carParts = [];\n\n      for await (const part of car) {\n        carParts.push(part);\n      }\n\n      const carFile = new Blob(carParts, {\n        type: 'application/car'\n      });\n      const cid = await pRetry(async () => {\n        const response = await fetch(url.toString(), {\n          method: 'POST',\n          headers,\n          body: carFile\n        });\n        /* c8 ignore next 3 */\n\n        if (response.status === 429) {\n          throw new Error('rate limited');\n        }\n\n        const result = await response.json();\n\n        if (!result.ok) {\n          // do not retry if unauthorized - will not succeed\n          if (response.status === 401) {\n            throw new AbortError(result.error.message);\n          }\n\n          throw new Error(result.error.message);\n        }\n\n        return result.value.cid;\n      }, {\n        retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries\n      });\n      onStoredChunk && onStoredChunk(carFile.size);\n      return cid;\n    });\n    let root;\n\n    for await (const cid of upload(splitter.cars())) {\n      root = cid;\n    }\n\n    return (\n      /** @type {CIDString} */\n      root\n    );\n  }\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {Iterable<File>} files\n   * @returns {Promise<CIDString>}\n   */\n\n\n  static async storeDirectory(service, files) {\n    const blockstore = new Blockstore();\n    let cidString;\n\n    try {\n      const {\n        cid,\n        car\n      } = await NFTStorage.encodeDirectory(files, {\n        blockstore\n      });\n      await NFTStorage.storeCar(service, car);\n      cidString = cid.toString();\n    } finally {\n      await blockstore.close();\n    }\n\n    return cidString;\n  }\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @returns {Promise<TokenType<T>>}\n   */\n\n\n  static async store(service, metadata) {\n    const {\n      token,\n      car\n    } = await NFTStorage.encodeNFT(metadata);\n    await NFTStorage.storeCar(service, car);\n    return token;\n  }\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n\n\n  static async status(_ref3, cid) {\n    let {\n      endpoint,\n      token\n    } = _ref3;\n    const url = new URL(`${cid}/`, endpoint);\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token)\n    });\n    /* c8 ignore next 3 */\n\n    if (response.status === 429) {\n      throw new Error('rate limited');\n    }\n\n    const result = await response.json();\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created)\n      };\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n\n\n  static async check(_ref4, cid) {\n    let {\n      endpoint\n    } = _ref4;\n    const url = new URL(`check/${cid}/`, endpoint);\n    const response = await fetch(url.toString());\n    /* c8 ignore next 3 */\n\n    if (response.status === 429) {\n      throw new Error('rate limited');\n    }\n\n    const result = await response.json();\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin\n      };\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @returns {Promise<void>}\n   */\n\n\n  static async delete(_ref5, cid) {\n    let {\n      endpoint,\n      token\n    } = _ref5;\n    const url = new URL(`${cid}/`, endpoint);\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token)\n    });\n    /* c8 ignore next 3 */\n\n    if (response.status === 429) {\n      throw new Error('rate limited');\n    }\n\n    const result = await response.json();\n\n    if (!result.ok) {\n      throw new Error(result.error.message);\n    }\n  }\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n\n\n  static async encodeNFT(input) {\n    validateERC1155(input);\n    return Token.Token.encode(input);\n  }\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n\n\n  static async encodeBlob(blob) {\n    let {\n      blockstore\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content');\n    }\n\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false\n    });\n  }\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Iterable<File>} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n\n\n  static async encodeDirectory(files) {\n    let {\n      blockstore\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const input = [];\n    let size = 0;\n\n    for (const file of files) {\n      input.push(toImportCandidate(file.name, file));\n      size += file.size;\n    }\n\n    if (size === 0) {\n      throw new Error('Total size of files should exceed 0, make sure to provide some content');\n    }\n\n    return packCar(input, {\n      blockstore,\n      wrapWithDirectory: true\n    });\n  } // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   */\n\n\n  storeBlob(blob) {\n    return NFTStorage.storeBlob(this, blob);\n  }\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n\n\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options);\n  }\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {Iterable<File>} files\n   */\n\n\n  storeDirectory(files) {\n    return NFTStorage.storeDirectory(this, files);\n  }\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   */\n\n\n  status(cid) {\n    return NFTStorage.status(this, cid);\n  }\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   */\n\n\n  delete(cid) {\n    return NFTStorage.delete(this, cid);\n  }\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   */\n\n\n  check(cid) {\n    return NFTStorage.check(this, cid);\n  }\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   */\n\n\n  store(token) {\n    return NFTStorage.store(this, token);\n  }\n\n}\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\n\n\nconst validateERC1155 = _ref6 => {\n  let {\n    name,\n    description,\n    image,\n    decimals\n  } = _ref6;\n\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError('string property `name` identifying the asset is required');\n  }\n\n  if (typeof description !== 'string') {\n    throw new TypeError('string property `description` describing asset is required');\n  }\n\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object');\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value');\n  }\n};\n/**\n * @param {Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\n\n\nconst packCar = async function (input) {\n  let {\n    blockstore,\n    wrapWithDirectory\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore();\n  const {\n    root: cid\n  } = await pack({\n    input,\n    blockstore,\n    wrapWithDirectory\n  });\n  const car = new BlockstoreCarReader(1, [cid], blockstore);\n  return {\n    cid,\n    car\n  };\n};\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\n\n\nconst decodeDeals = deals => deals.map(deal => {\n  const {\n    dealActivation,\n    dealExpiration,\n    lastChanged\n  } = {\n    dealExpiration: null,\n    dealActivation: null,\n    ...deal\n  };\n  return { ...deal,\n    lastChanged: new Date(lastChanged),\n    ...(dealActivation && {\n      dealActivation: new Date(dealActivation)\n    }),\n    ...(dealExpiration && {\n      dealExpiration: new Date(dealExpiration)\n    })\n  };\n});\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\n\n\nconst decodePin = pin => ({ ...pin,\n  created: new Date(pin.created)\n});\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Blob} blob\n */\n\n\nfunction toImportCandidate(path, blob) {\n  /** @type {ReadableStream} */\n  let stream;\n  return {\n    path,\n\n    get content() {\n      stream = stream || blob.stream();\n      return stream;\n    }\n\n  };\n}\n\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token };","map":{"version":3,"sources":["/Users/massimilianoalbini/Documents/gain-drop/gain-drop/node_modules/nft.storage/src/lib.js"],"names":["transform","pRetry","AbortError","TreewalkCarSplitter","pack","CID","Token","fetch","File","Blob","FormData","Blockstore","toGatewayURL","BlockstoreCarReader","MAX_STORE_RETRIES","MAX_CONCURRENT_UPLOADS","MAX_CHUNK_SIZE","NFTStorage","constructor","token","endpoint","URL","auth","Error","Authorization","storeBlob","service","blob","blockstore","cidString","cid","car","encodeBlob","storeCar","toString","close","onStoredChunk","maxRetries","decoders","url","headers","targetSize","splitter","fromBlob","upload","carParts","part","push","carFile","type","response","method","body","status","result","json","ok","error","message","value","retries","size","root","cars","storeDirectory","files","encodeDirectory","store","metadata","encodeNFT","deals","decodeDeals","pin","decodePin","created","Date","check","delete","input","validateERC1155","encode","packCar","toImportCandidate","wrapWithDirectory","file","name","options","description","image","decimals","TypeError","startsWith","console","warn","map","deal","dealActivation","dealExpiration","lastChanged","path","stream","content"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,SAAT,QAA0B,qBAA1B;AACA,OAAOC,MAAP,IAAiBC,UAAjB,QAAmC,SAAnC;AACA,SAASC,mBAAT,QAAoC,mBAApC;AACA,SAASC,IAAT,QAAqB,eAArB;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA,OAAO,KAAKC,KAAZ,MAAuB,YAAvB;AACA,SAASC,KAAT,EAAgBC,IAAhB,EAAsBC,IAAtB,EAA4BC,QAA5B,EAAsCC,UAAtC,QAAwD,eAAxD;AACA,SAASC,YAAT,QAA6B,cAA7B;AACA,SAASC,mBAAT,QAAoC,oBAApC;AAEA,MAAMC,iBAAiB,GAAG,CAA1B;AACA,MAAMC,sBAAsB,GAAG,CAA/B;AACA,MAAMC,cAAc,GAAG,OAAO,IAAP,GAAc,EAArC,C,CAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,UAAN,CAAiB;AACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,OAA2D;AAAA,QAA1D;AAAEC,MAAAA,KAAF;AAASC,MAAAA,QAAQ,GAAG,IAAIC,GAAJ,CAAQ,yBAAR;AAApB,KAA0D;;AACpE;AACJ;AACA;AACA;AACA;AACI,SAAKF,KAAL,GAAaA,KAAb;AACA;AACJ;AACA;AACA;;AACI,SAAKC,QAAL,GAAgBA,QAAhB;AACD;AAED;AACF;AACA;AACA;;;AACa,SAAJE,IAAI,CAACH,KAAD,EAAQ;AACjB,QAAI,CAACA,KAAL,EAAY,MAAM,IAAII,KAAJ,CAAU,eAAV,CAAN;AACZ,WAAO;AAAEC,MAAAA,aAAa,EAAG,UAASL,KAAM,EAAjC;AAAoC,kBAAY;AAAhD,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACwB,eAATM,SAAS,CAACC,OAAD,EAAUC,IAAV,EAAgB;AACpC,UAAMC,UAAU,GAAG,IAAIjB,UAAJ,EAAnB;AACA,QAAIkB,SAAJ;;AAEA,QAAI;AACF,YAAM;AAAEC,QAAAA,GAAF;AAAOC,QAAAA;AAAP,UAAe,MAAMd,UAAU,CAACe,UAAX,CAAsBL,IAAtB,EAA4B;AAAEC,QAAAA;AAAF,OAA5B,CAA3B;AACA,YAAMX,UAAU,CAACgB,QAAX,CAAoBP,OAApB,EAA6BK,GAA7B,CAAN;AACAF,MAAAA,SAAS,GAAGC,GAAG,CAACI,QAAJ,EAAZ;AACD,KAJD,SAIU;AACR,YAAMN,UAAU,CAACO,KAAX,EAAN;AACD;;AAED,WAAON,SAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACuB,eAARI,QAAQ,QAEnBF,GAFmB,EAInB;AAAA,QAHA;AAAEX,MAAAA,QAAF;AAAYD,MAAAA;AAAZ,KAGA;AAAA,QADA;AAAEiB,MAAAA,aAAF;AAAiBC,MAAAA,UAAjB;AAA6BC,MAAAA;AAA7B,KACA,uEAD0C,EAC1C;AACA,UAAMC,GAAG,GAAG,IAAIlB,GAAJ,CAAQ,SAAR,EAAmBD,QAAnB,CAAZ;AACA,UAAMoB,OAAO,GAAGvB,UAAU,CAACK,IAAX,CAAgBH,KAAhB,CAAhB;AACA,UAAMsB,UAAU,GAAGzB,cAAnB;AACA,UAAM0B,QAAQ,GACZX,GAAG,YAAYtB,IAAf,GACI,MAAMN,mBAAmB,CAACwC,QAApB,CAA6BZ,GAA7B,EAAkCU,UAAlC,EAA8C;AAAEH,MAAAA;AAAF,KAA9C,CADV,GAEI,IAAInC,mBAAJ,CAAwB4B,GAAxB,EAA6BU,UAA7B,EAAyC;AAAEH,MAAAA;AAAF,KAAzC,CAHN;AAKA,UAAMM,MAAM,GAAG5C,SAAS,CACtBe,sBADsB,EAEtB;AAAgB;AAAyCgB,IAAAA,GAAzD,EAA8D;AAC5D,YAAMc,QAAQ,GAAG,EAAjB;;AACA,iBAAW,MAAMC,IAAjB,IAAyBf,GAAzB,EAA8B;AAC5Bc,QAAAA,QAAQ,CAACE,IAAT,CAAcD,IAAd;AACD;;AACD,YAAME,OAAO,GAAG,IAAIvC,IAAJ,CAASoC,QAAT,EAAmB;AAAEI,QAAAA,IAAI,EAAE;AAAR,OAAnB,CAAhB;AACA,YAAMnB,GAAG,GAAG,MAAM7B,MAAM,CACtB,YAAY;AACV,cAAMiD,QAAQ,GAAG,MAAM3C,KAAK,CAACgC,GAAG,CAACL,QAAJ,EAAD,EAAiB;AAC3CiB,UAAAA,MAAM,EAAE,MADmC;AAE3CX,UAAAA,OAF2C;AAG3CY,UAAAA,IAAI,EAAEJ;AAHqC,SAAjB,CAA5B;AAKA;;AACA,YAAIE,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,gBAAM,IAAI9B,KAAJ,CAAU,cAAV,CAAN;AACD;;AACD,cAAM+B,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AACA,YAAI,CAACD,MAAM,CAACE,EAAZ,EAAgB;AACd;AACA,cAAIN,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,kBAAM,IAAInD,UAAJ,CAAeoD,MAAM,CAACG,KAAP,CAAaC,OAA5B,CAAN;AACD;;AACD,gBAAM,IAAInC,KAAJ,CAAU+B,MAAM,CAACG,KAAP,CAAaC,OAAvB,CAAN;AACD;;AACD,eAAOJ,MAAM,CAACK,KAAP,CAAa7B,GAApB;AACD,OApBqB,EAqBtB;AACE8B,QAAAA,OAAO,EAAEvB,UAAU,IAAI,IAAd,GAAqBvB,iBAArB,GAAyCuB;AADpD,OArBsB,CAAxB;AAyBAD,MAAAA,aAAa,IAAIA,aAAa,CAACY,OAAO,CAACa,IAAT,CAA9B;AACA,aAAO/B,GAAP;AACD,KAnCqB,CAAxB;AAsCA,QAAIgC,IAAJ;;AACA,eAAW,MAAMhC,GAAjB,IAAwBc,MAAM,CAACF,QAAQ,CAACqB,IAAT,EAAD,CAA9B,EAAiD;AAC/CD,MAAAA,IAAI,GAAGhC,GAAP;AACD;;AAED;AAAO;AAA0BgC,MAAAA;AAAjC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC6B,eAAdE,cAAc,CAACtC,OAAD,EAAUuC,KAAV,EAAiB;AAC1C,UAAMrC,UAAU,GAAG,IAAIjB,UAAJ,EAAnB;AACA,QAAIkB,SAAJ;;AAEA,QAAI;AACF,YAAM;AAAEC,QAAAA,GAAF;AAAOC,QAAAA;AAAP,UAAe,MAAMd,UAAU,CAACiD,eAAX,CAA2BD,KAA3B,EAAkC;AAC3DrC,QAAAA;AAD2D,OAAlC,CAA3B;AAGA,YAAMX,UAAU,CAACgB,QAAX,CAAoBP,OAApB,EAA6BK,GAA7B,CAAN;AACAF,MAAAA,SAAS,GAAGC,GAAG,CAACI,QAAJ,EAAZ;AACD,KAND,SAMU;AACR,YAAMN,UAAU,CAACO,KAAX,EAAN;AACD;;AAED,WAAON,SAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,eAALsC,KAAK,CAACzC,OAAD,EAAU0C,QAAV,EAAoB;AACpC,UAAM;AAAEjD,MAAAA,KAAF;AAASY,MAAAA;AAAT,QAAiB,MAAMd,UAAU,CAACoD,SAAX,CAAqBD,QAArB,CAA7B;AACA,UAAMnD,UAAU,CAACgB,QAAX,CAAoBP,OAApB,EAA6BK,GAA7B,CAAN;AACA,WAAOZ,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,eAANkC,MAAM,QAAsBvB,GAAtB,EAA2B;AAAA,QAA1B;AAAEV,MAAAA,QAAF;AAAYD,MAAAA;AAAZ,KAA0B;AAC5C,UAAMoB,GAAG,GAAG,IAAIlB,GAAJ,CAAS,GAAES,GAAI,GAAf,EAAmBV,QAAnB,CAAZ;AACA,UAAM8B,QAAQ,GAAG,MAAM3C,KAAK,CAACgC,GAAG,CAACL,QAAJ,EAAD,EAAiB;AAC3CiB,MAAAA,MAAM,EAAE,KADmC;AAE3CX,MAAAA,OAAO,EAAEvB,UAAU,CAACK,IAAX,CAAgBH,KAAhB;AAFkC,KAAjB,CAA5B;AAIA;;AACA,QAAI+B,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,YAAM,IAAI9B,KAAJ,CAAU,cAAV,CAAN;AACD;;AACD,UAAM+B,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,QAAID,MAAM,CAACE,EAAX,EAAe;AACb,aAAO;AACL1B,QAAAA,GAAG,EAAEwB,MAAM,CAACK,KAAP,CAAa7B,GADb;AAELwC,QAAAA,KAAK,EAAEC,WAAW,CAACjB,MAAM,CAACK,KAAP,CAAaW,KAAd,CAFb;AAGLT,QAAAA,IAAI,EAAEP,MAAM,CAACK,KAAP,CAAaE,IAHd;AAILW,QAAAA,GAAG,EAAEC,SAAS,CAACnB,MAAM,CAACK,KAAP,CAAaa,GAAd,CAJT;AAKLE,QAAAA,OAAO,EAAE,IAAIC,IAAJ,CAASrB,MAAM,CAACK,KAAP,CAAae,OAAtB;AALJ,OAAP;AAOD,KARD,MAQO;AACL,YAAM,IAAInD,KAAJ,CAAU+B,MAAM,CAACG,KAAP,CAAaC,OAAvB,CAAN;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACoB,eAALkB,KAAK,QAAe9C,GAAf,EAAoB;AAAA,QAAnB;AAAEV,MAAAA;AAAF,KAAmB;AACpC,UAAMmB,GAAG,GAAG,IAAIlB,GAAJ,CAAS,SAAQS,GAAI,GAArB,EAAyBV,QAAzB,CAAZ;AACA,UAAM8B,QAAQ,GAAG,MAAM3C,KAAK,CAACgC,GAAG,CAACL,QAAJ,EAAD,CAA5B;AACA;;AACA,QAAIgB,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,YAAM,IAAI9B,KAAJ,CAAU,cAAV,CAAN;AACD;;AACD,UAAM+B,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,QAAID,MAAM,CAACE,EAAX,EAAe;AACb,aAAO;AACL1B,QAAAA,GAAG,EAAEwB,MAAM,CAACK,KAAP,CAAa7B,GADb;AAELwC,QAAAA,KAAK,EAAEC,WAAW,CAACjB,MAAM,CAACK,KAAP,CAAaW,KAAd,CAFb;AAGLE,QAAAA,GAAG,EAAElB,MAAM,CAACK,KAAP,CAAaa;AAHb,OAAP;AAKD,KAND,MAMO;AACL,YAAM,IAAIjD,KAAJ,CAAU+B,MAAM,CAACG,KAAP,CAAaC,OAAvB,CAAN;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,eAANmB,MAAM,QAAsB/C,GAAtB,EAA2B;AAAA,QAA1B;AAAEV,MAAAA,QAAF;AAAYD,MAAAA;AAAZ,KAA0B;AAC5C,UAAMoB,GAAG,GAAG,IAAIlB,GAAJ,CAAS,GAAES,GAAI,GAAf,EAAmBV,QAAnB,CAAZ;AACA,UAAM8B,QAAQ,GAAG,MAAM3C,KAAK,CAACgC,GAAG,CAACL,QAAJ,EAAD,EAAiB;AAC3CiB,MAAAA,MAAM,EAAE,QADmC;AAE3CX,MAAAA,OAAO,EAAEvB,UAAU,CAACK,IAAX,CAAgBH,KAAhB;AAFkC,KAAjB,CAA5B;AAIA;;AACA,QAAI+B,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,YAAM,IAAI9B,KAAJ,CAAU,cAAV,CAAN;AACD;;AACD,UAAM+B,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AACA,QAAI,CAACD,MAAM,CAACE,EAAZ,EAAgB;AACd,YAAM,IAAIjC,KAAJ,CAAU+B,MAAM,CAACG,KAAP,CAAaC,OAAvB,CAAN;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,eAATW,SAAS,CAACS,KAAD,EAAQ;AAC5BC,IAAAA,eAAe,CAACD,KAAD,CAAf;AACA,WAAOxE,KAAK,CAACA,KAAN,CAAY0E,MAAZ,CAAmBF,KAAnB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACyB,eAAV9C,UAAU,CAACL,IAAD,EAA4B;AAAA,QAArB;AAAEC,MAAAA;AAAF,KAAqB,uEAAJ,EAAI;;AACjD,QAAID,IAAI,CAACkC,IAAL,KAAc,CAAlB,EAAqB;AACnB,YAAM,IAAItC,KAAJ,CAAU,sDAAV,CAAN;AACD;;AACD,WAAO0D,OAAO,CAAC,CAACC,iBAAiB,CAAC,MAAD,EAASvD,IAAT,CAAlB,CAAD,EAAoC;AAChDC,MAAAA,UADgD;AAEhDuD,MAAAA,iBAAiB,EAAE;AAF6B,KAApC,CAAd;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC8B,eAAfjB,eAAe,CAACD,KAAD,EAA6B;AAAA,QAArB;AAAErC,MAAAA;AAAF,KAAqB,uEAAJ,EAAI;AACvD,UAAMkD,KAAK,GAAG,EAAd;AACA,QAAIjB,IAAI,GAAG,CAAX;;AACA,SAAK,MAAMuB,IAAX,IAAmBnB,KAAnB,EAA0B;AACxBa,MAAAA,KAAK,CAAC/B,IAAN,CAAWmC,iBAAiB,CAACE,IAAI,CAACC,IAAN,EAAYD,IAAZ,CAA5B;AACAvB,MAAAA,IAAI,IAAIuB,IAAI,CAACvB,IAAb;AACD;;AAED,QAAIA,IAAI,KAAK,CAAb,EAAgB;AACd,YAAM,IAAItC,KAAJ,CACJ,wEADI,CAAN;AAGD;;AAED,WAAO0D,OAAO,CAACH,KAAD,EAAQ;AACpBlD,MAAAA,UADoB;AAEpBuD,MAAAA,iBAAiB,EAAE;AAFC,KAAR,CAAd;AAID,GA5Yc,CA8Yf;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE1D,EAAAA,SAAS,CAACE,IAAD,EAAO;AACd,WAAOV,UAAU,CAACQ,SAAX,CAAqB,IAArB,EAA2BE,IAA3B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEM,EAAAA,QAAQ,CAACF,GAAD,EAAMuD,OAAN,EAAe;AACrB,WAAOrE,UAAU,CAACgB,QAAX,CAAoB,IAApB,EAA0BF,GAA1B,EAA+BuD,OAA/B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEtB,EAAAA,cAAc,CAACC,KAAD,EAAQ;AACpB,WAAOhD,UAAU,CAAC+C,cAAX,CAA0B,IAA1B,EAAgCC,KAAhC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEZ,EAAAA,MAAM,CAACvB,GAAD,EAAM;AACV,WAAOb,UAAU,CAACoC,MAAX,CAAkB,IAAlB,EAAwBvB,GAAxB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE+C,EAAAA,MAAM,CAAC/C,GAAD,EAAM;AACV,WAAOb,UAAU,CAAC4D,MAAX,CAAkB,IAAlB,EAAwB/C,GAAxB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE8C,EAAAA,KAAK,CAAC9C,GAAD,EAAM;AACT,WAAOb,UAAU,CAAC2D,KAAX,CAAiB,IAAjB,EAAuB9C,GAAvB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEqC,EAAAA,KAAK,CAAChD,KAAD,EAAQ;AACX,WAAOF,UAAU,CAACkD,KAAX,CAAiB,IAAjB,EAAuBhD,KAAvB,CAAP;AACD;;AAzjBc;AA4jBjB;AACA;AACA;AACA;;;AACA,MAAM4D,eAAe,GAAG,SAA4C;AAAA,MAA3C;AAAEM,IAAAA,IAAF;AAAQE,IAAAA,WAAR;AAAqBC,IAAAA,KAArB;AAA4BC,IAAAA;AAA5B,GAA2C;;AAClE;AACA,MAAI,OAAOJ,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAIK,SAAJ,CACJ,0DADI,CAAN;AAGD;;AACD,MAAI,OAAOH,WAAP,KAAuB,QAA3B,EAAqC;AACnC,UAAM,IAAIG,SAAJ,CACJ,4DADI,CAAN;AAGD;;AACD,MAAI,EAAEF,KAAK,YAAY/E,IAAnB,CAAJ,EAA8B;AAC5B,UAAM,IAAIiF,SAAJ,CAAc,gDAAd,CAAN;AACD,GAFD,MAEO,IAAI,CAACF,KAAK,CAACvC,IAAN,CAAW0C,UAAX,CAAsB,QAAtB,CAAL,EAAsC;AAC3CC,IAAAA,OAAO,CAACC,IAAR,CAAc;AAClB;AACA;AACA;AACA,yFAJI;AAKD;;AAED,MAAI,OAAOJ,QAAP,KAAoB,WAApB,IAAmC,OAAOA,QAAP,KAAoB,QAA3D,EAAqE;AACnE,UAAM,IAAIC,SAAJ,CAAc,8CAAd,CAAN;AACD;AACF,CAzBD;AA2BA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMT,OAAO,GAAG,gBAAOH,KAAP,EAAyD;AAAA,MAA3C;AAAElD,IAAAA,UAAF;AAAcuD,IAAAA;AAAd,GAA2C,uEAAP,EAAO;;AACvE;AACAvD,EAAAA,UAAU,GAAGA,UAAU,IAAI,IAAIjB,UAAJ,EAA3B;AACA,QAAM;AAAEmD,IAAAA,IAAI,EAAEhC;AAAR,MAAgB,MAAM1B,IAAI,CAAC;AAAE0E,IAAAA,KAAF;AAASlD,IAAAA,UAAT;AAAqBuD,IAAAA;AAArB,GAAD,CAAhC;AACA,QAAMpD,GAAG,GAAG,IAAIlB,mBAAJ,CAAwB,CAAxB,EAA2B,CAACiB,GAAD,CAA3B,EAAkCF,UAAlC,CAAZ;AACA,SAAO;AAAEE,IAAAA,GAAF;AAAOC,IAAAA;AAAP,GAAP;AACD,CAND;AAQA;AACA;AACA;AACA;;;AACA,MAAMwC,WAAW,GAAID,KAAD,IAClBA,KAAK,CAACwB,GAAN,CAAWC,IAAD,IAAU;AAClB,QAAM;AAAEC,IAAAA,cAAF;AAAkBC,IAAAA,cAAlB;AAAkCC,IAAAA;AAAlC,MAAkD;AACtDD,IAAAA,cAAc,EAAE,IADsC;AAEtDD,IAAAA,cAAc,EAAE,IAFsC;AAGtD,OAAGD;AAHmD,GAAxD;AAMA,SAAO,EACL,GAAGA,IADE;AAELG,IAAAA,WAAW,EAAE,IAAIvB,IAAJ,CAASuB,WAAT,CAFR;AAGL,QAAIF,cAAc,IAAI;AAAEA,MAAAA,cAAc,EAAE,IAAIrB,IAAJ,CAASqB,cAAT;AAAlB,KAAtB,CAHK;AAIL,QAAIC,cAAc,IAAI;AAAEA,MAAAA,cAAc,EAAE,IAAItB,IAAJ,CAASsB,cAAT;AAAlB,KAAtB;AAJK,GAAP;AAMD,CAbD,CADF;AAgBA;AACA;AACA;AACA;;;AACA,MAAMxB,SAAS,GAAID,GAAD,KAAU,EAAE,GAAGA,GAAL;AAAUE,EAAAA,OAAO,EAAE,IAAIC,IAAJ,CAASH,GAAG,CAACE,OAAb;AAAnB,CAAV,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,iBAAT,CAA2BiB,IAA3B,EAAiCxE,IAAjC,EAAuC;AACrC;AACA,MAAIyE,MAAJ;AACA,SAAO;AACLD,IAAAA,IADK;;AAEL,QAAIE,OAAJ,GAAc;AACZD,MAAAA,MAAM,GAAGA,MAAM,IAAIzE,IAAI,CAACyE,MAAL,EAAnB;AACA,aAAOA,MAAP;AACD;;AALI,GAAP;AAOD;;AAED,SAASnF,UAAT,EAAqBT,IAArB,EAA2BC,IAA3B,EAAiCC,QAAjC,EAA2CE,YAA3C,EAAyDN,KAAzD","sourcesContent":["/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport * as Token from './token.js'\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 10 // chunk to ~10MB CARs\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements Service\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?:URL}} options\n   */\n  constructor({ token, endpoint = new URL('https://api.nft.storage') }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   */\n  static auth(token) {\n    if (!token) throw new Error('missing token')\n    return { Authorization: `Bearer ${token}`, 'X-Client': 'nft.storage/js' }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob) {\n    const blockstore = new Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, token },\n    car,\n    { onStoredChunk, maxRetries, decoders } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = NFTStorage.auth(token)\n    const targetSize = MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof Blob\n        ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = transform(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new Blob(carParts, { type: 'application/car' })\n        const cid = await pRetry(\n          async () => {\n            const response = await fetch(url.toString(), {\n              method: 'POST',\n              headers,\n              body: carFile,\n            })\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {Iterable<File>} files\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, files) {\n    const blockstore = new Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(files, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status({ endpoint, token }, cid) {\n    const url = new URL(`${cid}/`, endpoint)\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check({ endpoint }, cid) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    const response = await fetch(url.toString())\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @returns {Promise<void>}\n   */\n  static async delete({ endpoint, token }, cid) {\n    const url = new URL(`${cid}/`, endpoint)\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return Token.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Iterable<File>} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    const input = []\n    let size = 0\n    for (const file of files) {\n      input.push(toImportCandidate(file.name, file))\n      size += file.size\n    }\n\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n\n    return packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   */\n  storeBlob(blob) {\n    return NFTStorage.storeBlob(this, blob)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {Iterable<File>} files\n   */\n  storeDirectory(files) {\n    return NFTStorage.storeDirectory(this, files)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   */\n  status(cid) {\n    return NFTStorage.status(this, cid)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   */\n  delete(cid) {\n    return NFTStorage.delete(this, cid)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   */\n  check(cid) {\n    return NFTStorage.check(this, cid)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   */\n  store(token) {\n    return NFTStorage.store(this, token)\n  }\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore()\n  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory })\n  const car = new BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Blob} blob\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {ReadableStream} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token }\n"]},"metadata":{},"sourceType":"module"}