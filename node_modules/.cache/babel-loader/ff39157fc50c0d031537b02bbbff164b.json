{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar bcUrRegistry = require('@keystonehq/bc-ur-registry');\n\nvar uuid = require('uuid');\n\nvar HDKey = _interopDefault(require('hdkey'));\n\nvar ethereumjsUtil = require('ethereumjs-util');\n\nconst {\n  RegistryType\n} = bcUrRegistry.extend;\nconst ExtendedRegistryTypes = {\n  ETH_SIGN_REQUEST: /*#__PURE__*/new RegistryType('eth-sign-request', 401),\n  ETH_SIGNATAURE: /*#__PURE__*/new RegistryType('eth-signature', 402)\n};\nconst {\n  decodeToDataItem,\n  RegistryTypes\n} = bcUrRegistry.extend;\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"requestId\"] = 1] = \"requestId\";\n  Keys[Keys[\"signData\"] = 2] = \"signData\";\n  Keys[Keys[\"dataType\"] = 3] = \"dataType\";\n  Keys[Keys[\"chainId\"] = 4] = \"chainId\";\n  Keys[Keys[\"derivationPath\"] = 5] = \"derivationPath\";\n  Keys[Keys[\"address\"] = 6] = \"address\";\n  Keys[Keys[\"origin\"] = 7] = \"origin\";\n})(Keys || (Keys = {}));\n\n(function (DataType) {\n  DataType[DataType[\"transaction\"] = 1] = \"transaction\";\n  DataType[DataType[\"typedData\"] = 2] = \"typedData\";\n  DataType[DataType[\"personalMessage\"] = 3] = \"personalMessage\";\n  DataType[DataType[\"typedTransaction\"] = 4] = \"typedTransaction\";\n})(exports.DataType || (exports.DataType = {}));\n\nclass EthSignRequest extends bcUrRegistry.RegistryItem {\n  constructor(args) {\n    super();\n\n    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n    this.setupData = args => {\n      this.requestId = args.requestId;\n      this.signData = args.signData;\n      this.dataType = args.dataType;\n      this.chainId = args.chainId;\n      this.derivationPath = args.derivationPath;\n      this.address = args.address;\n      this.origin = args.origin;\n    };\n\n    this.getRequestId = () => this.requestId;\n\n    this.getSignData = () => this.signData;\n\n    this.getDataType = () => this.dataType;\n\n    this.getChainId = () => this.chainId;\n\n    this.getDerivationPath = () => this.derivationPath.getPath();\n\n    this.getSignRequestAddress = () => this.address;\n\n    this.getOrigin = () => this.origin;\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.requestId) {\n        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());\n      }\n\n      if (this.address) {\n        map[Keys.address] = this.address;\n      }\n\n      if (this.chainId) {\n        map[Keys.chainId] = this.chainId;\n      }\n\n      if (this.origin) {\n        map[Keys.origin] = this.origin;\n      }\n\n      map[Keys.signData] = this.signData;\n      map[Keys.dataType] = this.dataType;\n      const keyPath = this.derivationPath.toDataItem();\n      keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n      map[Keys.derivationPath] = keyPath;\n      return new bcUrRegistry.DataItem(map);\n    };\n\n    this.setupData(args);\n  }\n\n  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {\n    const paths = hdPath.replace(/[m|M]\\//, '').split('/');\n    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {\n      const index = parseInt(path.replace(\"'\", ''));\n      let isHardened = false;\n\n      if (path.endsWith(\"'\")) {\n        isHardened = true;\n      }\n\n      return new bcUrRegistry.PathComponent({\n        index,\n        hardened: isHardened\n      });\n    }), Buffer.from(xfp, 'hex'));\n    return new EthSignRequest({\n      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,\n      signData,\n      dataType: signDataType,\n      derivationPath: hdpathObject,\n      chainId,\n      address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,\n      origin: origin || undefined\n    });\n  }\n\n}\n\nEthSignRequest.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const signData = map[Keys.signData];\n  const dataType = map[Keys.dataType];\n  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n  const address = map[Keys.address] ? map[Keys.address] : undefined;\n  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n  return new EthSignRequest({\n    requestId,\n    signData,\n    dataType,\n    chainId,\n    derivationPath,\n    address,\n    origin\n  });\n};\n\nEthSignRequest.fromCBOR = _cborPayload => {\n  const dataItem = decodeToDataItem(_cborPayload);\n  return EthSignRequest.fromDataItem(dataItem);\n};\n\nconst {\n  RegistryTypes: RegistryTypes$1,\n  decodeToDataItem: decodeToDataItem$1\n} = bcUrRegistry.extend;\nvar Keys$1;\n\n(function (Keys) {\n  Keys[Keys[\"requestId\"] = 1] = \"requestId\";\n  Keys[Keys[\"signature\"] = 2] = \"signature\";\n})(Keys$1 || (Keys$1 = {}));\n\nclass ETHSignature extends bcUrRegistry.RegistryItem {\n  constructor(signature, requestId) {\n    super();\n\n    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n    this.getRequestId = () => this.requestId;\n\n    this.getSignature = () => this.signature;\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.requestId) {\n        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());\n      }\n\n      map[Keys$1.signature] = this.signature;\n      return new bcUrRegistry.DataItem(map);\n    };\n\n    this.signature = signature;\n    this.requestId = requestId;\n  }\n\n}\n\nETHSignature.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const signature = map[Keys$1.signature];\n  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;\n  return new ETHSignature(signature, requestId);\n};\n\nETHSignature.fromCBOR = _cborPayload => {\n  const dataItem = decodeToDataItem$1(_cborPayload);\n  return ETHSignature.fromDataItem(dataItem);\n}; // @ts-ignore\n\n\nconst generateAddressfromXpub = (xpub, derivePath) => {\n  // @ts-ignore\n  const node = HDKey.fromExtendedKey(xpub);\n  const publicKey = node.derive(derivePath);\n  const address = '0x' + ethereumjsUtil.publicToAddress(publicKey.publicKey, true).toString('hex');\n  return ethereumjsUtil.toChecksumAddress(address);\n};\n\nconst findHDpatfromAddress = (address, xpub, numberLimit, rootPath) => {\n  for (let i = 0; i < numberLimit; i++) {\n    const path = `M/0/${i}`;\n    const caculateAddress = generateAddressfromXpub(xpub, path);\n\n    if (address.toLowerCase() == caculateAddress.toLowerCase()) {\n      return `${rootPath}/0/${i}`;\n    }\n  }\n\n  return null;\n};\n\nconst {\n  cbor\n} = bcUrRegistry.extend;\ncbor.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));\nObject.keys(bcUrRegistry).forEach(function (k) {\n  if (k !== 'default') Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return bcUrRegistry[k];\n    }\n  });\n});\nexports.ETHSignature = ETHSignature;\nexports.EthSignRequest = EthSignRequest;\nexports.findHDpatfromAddress = findHDpatfromAddress;\nexports.generateAddressfromXpub = generateAddressfromXpub;","map":{"version":3,"mappings":"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","names":["RegistryType","extend","ExtendedRegistryTypes","ETH_SIGN_REQUEST","ETH_SIGNATAURE","decodeToDataItem","RegistryTypes","Keys","DataType","EthSignRequest","RegistryItem","constructor","args","requestId","signData","dataType","chainId","derivationPath","address","origin","getPath","map","DataItem","UUID","getTag","keyPath","toDataItem","setTag","getRegistryType","setupData","constructETHRequest","signDataType","hdPath","xfp","uuidString","paths","replace","split","hdpathObject","CryptoKeypath","path","index","parseInt","isHardened","endsWith","PathComponent","hardened","Buffer","from","uuid","undefined","dataItem","getData","fromDataItem","_cborPayload","ETHSignature","signature","generateAddressfromXpub","xpub","derivePath","node","HDKey","fromExtendedKey","publicKey","derive","publicToAddress","toString","toChecksumAddress","findHDpatfromAddress","numberLimit","rootPath","i","caculateAddress","toLowerCase","cbor","patchTags","Object","values","filter","rt"],"sources":["../src/RegistryType.ts","../src/EthSignRequest.ts","../src/EthSignature.ts","../src/utlis.ts","../src/index.ts"],"sourcesContent":["import { extend } from '@keystonehq/bc-ur-registry';\nconst { RegistryType } = extend;\n\nexport const ExtendedRegistryTypes = {\n    ETH_SIGN_REQUEST: new RegistryType('eth-sign-request', 401),\n    ETH_SIGNATAURE: new RegistryType('eth-signature', 402),\n};\n","import { CryptoKeypath, extend, DataItem, PathComponent, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nimport * as uuid from 'uuid';\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nenum Keys {\n    requestId = 1,\n    signData,\n    dataType,\n    chainId,\n    derivationPath,\n    address,\n    origin\n}\n\nexport enum DataType {\n    transaction = 1,\n    typedData = 2,\n    personalMessage = 3,\n    typedTransaction = 4,\n}\n\ntype signRequestProps = {\n    requestId?: Buffer;\n    signData: Buffer;\n    dataType: DataType;\n    chainId?: number;\n    derivationPath: CryptoKeypath;\n    address?: Buffer;\n    origin?: String;\n};\n\nexport class EthSignRequest extends RegistryItem {\n    private requestId: Buffer;\n    private signData: Buffer;\n    private dataType: DataType;\n    private chainId: number;\n    private derivationPath: CryptoKeypath;\n    private address: Buffer;\n    private origin: String;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n    constructor(args: signRequestProps) {\n        super();\n        this.setupData(args);\n    }\n\n    private setupData = (args: signRequestProps) => {\n        this.requestId = args.requestId;\n        this.signData = args.signData;\n        this.dataType = args.dataType;\n        this.chainId = args.chainId;\n        this.derivationPath = args.derivationPath;\n        this.address = args.address;\n        this.origin = args.origin;\n    };\n\n    public getRequestId = () => this.requestId;\n    public getSignData = () => this.signData;\n    public getDataType = () => this.dataType;\n    public getChainId = () => this.chainId;\n    public getDerivationPath = () => this.derivationPath.getPath();\n    public getSignRequestAddress = () => this.address;\n    public getOrigin = () => this.origin;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        if (this.address) {\n            map[Keys.address] = this.address;\n        }\n        if (this.chainId) {\n            map[Keys.chainId] = this.chainId;\n        }\n\n        if(this.origin) {\n            map[Keys.origin] = this.origin;\n        }\n\n        map[Keys.signData] = this.signData;\n        map[Keys.dataType] = this.dataType;\n\n        const keyPath = this.derivationPath.toDataItem();\n        keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n        map[Keys.derivationPath] = keyPath;\n\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signData = map[Keys.signData];\n        const dataType = map[Keys.dataType];\n        const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n        const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n        const address = map[Keys.address] ? map[Keys.address] : undefined;\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n        const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n\n        return new EthSignRequest({\n            requestId,\n            signData,\n            dataType,\n            chainId,\n            derivationPath,\n            address,\n            origin\n        });\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return EthSignRequest.fromDataItem(dataItem);\n    };\n\n    public static constructETHRequest(\n        signData: Buffer,\n        signDataType: DataType,\n        hdPath: string,\n        xfp: string,\n        uuidString?: string,\n        chainId?: number,\n        address?: string,\n        origin?: string,\n    ) {\n        const paths = hdPath.replace(/[m|M]\\//, '').split('/');\n        const hdpathObject = new CryptoKeypath(\n            paths.map((path) => {\n                const index = parseInt(path.replace(\"'\", ''));\n                let isHardened = false;\n                if (path.endsWith(\"'\")) {\n                    isHardened = true;\n                }\n                return new PathComponent({ index, hardened: isHardened });\n            }),\n            Buffer.from(xfp, 'hex'),\n        );\n\n        return new EthSignRequest({\n            requestId: uuidString ? Buffer.from(uuid.parse(uuidString) as Uint8Array) : undefined,\n            signData,\n            dataType: signDataType,\n            derivationPath: hdpathObject,\n            chainId,\n            address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,\n            origin: origin || undefined,\n        });\n    }\n}\n","import { extend, DataItem, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n    requestId = 1,\n    signature,\n}\n\nexport class ETHSignature extends RegistryItem {\n    private requestId: Buffer;\n    private signature: Buffer;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n    constructor(signature: Buffer, requestId?: Buffer) {\n        super();\n        this.signature = signature;\n        this.requestId = requestId;\n    }\n\n    public getRequestId = () => this.requestId;\n    public getSignature = () => this.signature;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        map[Keys.signature] = this.signature;\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signature = map[Keys.signature];\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n\n        return new ETHSignature(signature, requestId);\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return ETHSignature.fromDataItem(dataItem);\n    };\n}\n","// @ts-ignore\nimport HDKey from 'hdkey';\nimport { toChecksumAddress, publicToAddress } from 'ethereumjs-util';\n\nexport const generateAddressfromXpub = (xpub: string, derivePath: string) => {\n    // @ts-ignore\n    const node = HDKey.fromExtendedKey(xpub);\n    const publicKey = node.derive(derivePath);\n    const address = '0x' + publicToAddress(publicKey.publicKey, true).toString('hex');\n    return toChecksumAddress(address);\n};\n\nexport const findHDpatfromAddress = (address: string, xpub: string, numberLimit: number, rootPath: string) => {\n    for (let i = 0; i < numberLimit; i++) {\n        const path = `M/0/${i}`;\n        const caculateAddress = generateAddressfromXpub(xpub, path);\n        if (address.toLowerCase() == caculateAddress.toLowerCase()) {\n            return `${rootPath}/0/${i}`;\n        }\n    }\n    return null;\n};\n","export * from '@keystonehq/bc-ur-registry';\nimport { extend } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nconst { cbor } = extend;\ncbor.patchTags(\n    Object.values(ExtendedRegistryTypes)\n        .filter((rt) => !!rt.getTag())\n        .map((rt) => rt.getTag()),\n);\n\nexport { EthSignRequest, DataType } from './EthSignRequest';\nexport { ETHSignature } from './EthSignature';\n\nexport { generateAddressfromXpub, findHDpatfromAddress } from './utlis';\n"]},"metadata":{},"sourceType":"script"}