{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\n\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst ur_1 = __importDefault(require(\"./ur\"));\n\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\n\nclass URDecoder {\n  constructor() {\n    let fountainDecoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new fountainDecoder_1.default();\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n    return true;\n  }\n\n  static decode(message) {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n\n    return [type, components.slice(1)];\n  }\n\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s);\n\n    if (!this.validatePart(type)) {\n      return false;\n    } // If this is a single-part UR then we're done\n\n\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n\n  isError() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n\n}\n\nexports.default = URDecoder;","map":{"version":3,"mappings":"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","names":["URDecoder","constructor","fountainDecoder","fountainDecoder_1","type","assert_1","utils_1","expected_type","decodeBody","message","cbor","bytewords_1","decode","STYLES","MINIMAL","ur_1","Buffer","from","validatePart","components","parse","length","errors_1","body","lowercase","toLowerCase","prefix","slice","split","parseSequenceComponent","s","seqNum","Number","seqLength","receivePart","result","undefined","seq","fragment","part","fountainEncoder_1","fromCBOR","isSuccess","resultMessage","isFailure","error","resultUR","isComplete","isError","resultError","expectedPartCount","expectedPartIndexes","getExpectedPartIndexes","receivedPartIndexes","getReceivedPartIndexes","lastPartIndexes","getLastPartIndexes","estimatedPercentComplete","getProgress","exports"],"sourceRoot":"","sources":["../src/urDecoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}