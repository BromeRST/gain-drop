{"ast":null,"code":"/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables';\nimport pRetry from 'p-retry';\nimport { pack } from 'ipfs-car/pack';\nimport { parseLinkHeader } from '@web3-storage/parse-link-header';\nimport { unpackStream } from 'ipfs-car/unpack';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport { CarReader } from '@ipld/car';\nimport { filesFromPath, getFilesFromPath } from 'files-from-path';\nimport { fetch, File, Blob, Blockstore } from './platform.js';\nconst MAX_PUT_RETRIES = 5;\nconst MAX_CONCURRENT_UPLOADS = 3;\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 10; // chunk to ~10MB CARs\n\nconst MAX_BLOCK_SIZE = 1048576;\nconst MAX_CHUNK_SIZE = 104857600;\n/** @typedef { import('./lib/interface.js').API } API */\n\n/** @typedef { import('./lib/interface.js').Status} Status */\n\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n\n/** @typedef { import('./lib/interface.js').Service } Service */\n\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * @implements Service\n */\n\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n   * @param {{token: string, endpoint?:URL}} options\n   */\n  constructor(_ref) {\n    let {\n      token,\n      endpoint = new URL('https://api.web3.storage')\n    } = _ref;\n\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n\n    this.endpoint = endpoint;\n  }\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n\n\n  static headers(token) {\n    if (!token) throw new Error('missing token');\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    };\n  }\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n\n\n  static async put(_ref2, files) {\n    let {\n      endpoint,\n      token\n    } = _ref2;\n    let {\n      onRootCidReady,\n      onStoredChunk,\n      maxRetries = MAX_PUT_RETRIES,\n      maxChunkSize = DEFAULT_CHUNK_SIZE,\n      wrapWithDirectory = true,\n      name\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB');\n    }\n\n    const blockstore = new Blockstore();\n\n    try {\n      const {\n        out,\n        root\n      } = await pack({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      });\n      onRootCidReady && onRootCidReady(root.toString());\n      const car = await CarReader.fromIterable(out);\n      return await Web3Storage.putCar({\n        endpoint,\n        token\n      }, car, {\n        onStoredChunk,\n        maxRetries,\n        maxChunkSize,\n        name\n      });\n    } finally {\n      await blockstore.close();\n    }\n  }\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n\n\n  static async putCar(_ref3, car) {\n    let {\n      endpoint,\n      token\n    } = _ref3;\n    let {\n      name,\n      onStoredChunk,\n      maxRetries = MAX_PUT_RETRIES,\n      maxChunkSize = DEFAULT_CHUNK_SIZE,\n      decoders\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB');\n    }\n\n    const targetSize = maxChunkSize;\n    const url = new URL('car', endpoint);\n    let headers = Web3Storage.headers(token);\n\n    if (name) {\n      headers = { ...headers,\n        'X-Name': encodeURIComponent(name)\n      };\n    }\n\n    const roots = await car.getRoots();\n\n    if (roots[0] == null) {\n      throw new Error('missing root CID');\n    }\n\n    if (roots.length > 1) {\n      throw new Error('too many roots');\n    }\n\n    const carRoot = roots[0].toString();\n    const splitter = new TreewalkCarSplitter(car, targetSize, {\n      decoders\n    });\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n\n    const onCarChunk = async car => {\n      const carParts = [];\n\n      for await (const part of car) {\n        carParts.push(part);\n      }\n\n      const carFile = new Blob(carParts, {\n        type: 'application/car'\n      });\n      const res = await pRetry(async () => {\n        const request = await fetch(url.toString(), {\n          method: 'POST',\n          headers,\n          body: carFile\n        });\n        /* c8 ignore next 3 */\n\n        if (request.status === 429) {\n          throw new Error('rate limited');\n        }\n\n        const res = await request.json();\n\n        if (!request.ok) {\n          throw new Error(res.message);\n        }\n\n        if (res.cid !== carRoot) {\n          throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`);\n        }\n\n        return res.cid;\n      }, {\n        retries: maxRetries\n      });\n      onStoredChunk && onStoredChunk(carFile.size);\n      return res;\n    };\n\n    const upload = transform(MAX_CONCURRENT_UPLOADS, onCarChunk);\n\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n\n\n    return carRoot;\n  }\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @returns {Promise<Web3Response | null>}\n   */\n\n\n  static async get(_ref4, cid) {\n    let {\n      endpoint,\n      token\n    } = _ref4;\n    const url = new URL(`car/${cid}`, endpoint);\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token)\n    });\n    /* c8 ignore next 3 */\n\n    if (res.status === 429) {\n      throw new Error('rate limited');\n    }\n\n    return toWeb3Response(res);\n  }\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @returns {Promise<CIDString>}\n   */\n\n  /* c8 ignore next 4 */\n\n\n  static async delete(_ref5, cid) {\n    let {\n      endpoint,\n      token\n    } = _ref5;\n    console.log('Not deleting', cid, endpoint, token);\n    throw Error('.delete not implemented yet');\n  }\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @returns {Promise<Status | undefined>}\n   */\n\n\n  static async status(_ref6, cid) {\n    let {\n      endpoint,\n      token\n    } = _ref6;\n    const url = new URL(`status/${cid}`, endpoint);\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token)\n    });\n    /* c8 ignore next 3 */\n\n    if (res.status === 429) {\n      throw new Error('rate limited');\n    }\n\n    if (res.status === 404) {\n      return undefined;\n    }\n\n    if (!res.ok) {\n      throw new Error(res.statusText);\n    }\n\n    return res.json();\n  }\n  /**\n   * @param {Service} service\n   * @param {object} [opts]\n   * @param {string} [opts.before] list items uploaded before this ISO 8601 date string\n   * @param {number} [opts.maxResults] maximum number of results to return\n   * @returns {AsyncIterable<Upload>}\n   */\n\n\n  static async *list(service) {\n    let {\n      before = new Date().toISOString(),\n      maxResults = Infinity\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {Service} service\n     * @param {{before: string, size: number}} opts\n     * @returns {Promise<Response>}\n     */\n    function listPage(_ref7, _ref8) {\n      let {\n        endpoint,\n        token\n      } = _ref7;\n      let {\n        before,\n        size\n      } = _ref8;\n      const search = new URLSearchParams({\n        before,\n        size: size.toString()\n      });\n      const url = new URL(`user/uploads?${search}`, endpoint);\n      return fetch(url.toString(), {\n        method: 'GET',\n        headers: { ...Web3Storage.headers(token),\n          'Access-Control-Request-Headers': 'Link'\n        }\n      });\n    }\n\n    let count = 0;\n    const size = maxResults > 100 ? 100 : maxResults;\n\n    for await (const res of paginator(listPage, service, {\n      before,\n      size\n    })) {\n      if (!res.ok) {\n        /* c8 ignore next 3 */\n        if (res.status === 429) {\n          throw new Error('rate limited');\n        }\n        /* c8 ignore next 2 */\n\n\n        const errorMessage = await res.json();\n        throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`);\n      }\n\n      const page = await res.json();\n\n      for (const upload of page) {\n        if (++count > maxResults) {\n          return;\n        }\n\n        yield upload;\n      }\n    }\n  } // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n\n\n  put(files, options) {\n    return Web3Storage.put(this, files, options);\n  }\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n    *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n    *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n\n\n  putCar(car, options) {\n    return Web3Storage.putCar(this, car, options);\n  }\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   */\n\n\n  get(cid) {\n    return Web3Storage.get(this, cid);\n  }\n  /**\n   * @param {CIDString} cid\n   */\n\n  /* c8 ignore next 3 */\n\n\n  delete(cid) {\n    return Web3Storage.delete(this, cid);\n  }\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   */\n\n\n  status(cid) {\n    return Web3Storage.status(this, cid);\n  }\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {object} [opts]\n   * @param {string} [opts.before] list items uploaded before this ISO 8601 date string\n   * @param {number} [opts.maxResults] maximum number of results to return\n   * @returns {AsyncIterable<Upload>}\n   */\n\n\n  list(opts) {\n    return Web3Storage.list(this, opts);\n  }\n\n}\n/**\n * Map a UnixFSEntry to a File with a cid property\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\n\n\nasync function toWeb3File(_ref9) {\n  let {\n    content,\n    path,\n    cid\n  } = _ref9;\n  const chunks = [];\n\n  for await (const chunk of content()) {\n    chunks.push(chunk);\n  }\n\n  const file = new File(chunks, toFilenameWithPath(path));\n  return Object.assign(file, {\n    cid: cid.toString()\n  });\n}\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\n\n\nfunction toFilenameWithPath(unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/');\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1);\n}\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\n\n\nfunction toWeb3Response(res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function* () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`);\n      }\n      /* c8 ignore next 3 */\n\n\n      if (!res.body) {\n        throw new Error('No body on response');\n      }\n\n      const blockstore = new Blockstore();\n\n      try {\n        for await (const entry of unpackStream(res.body, {\n          blockstore\n        })) {\n          yield entry;\n        }\n      } finally {\n        await blockstore.close();\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`);\n      }\n\n      const files = []; // @ts-ignore we're using the enriched response here\n\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue;\n        }\n\n        const file = await toWeb3File(entry);\n        files.push(file);\n      }\n\n      return files;\n    }\n  });\n  return response;\n}\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\n\n\nfunction toImportCandidate(file) {\n  /** @type {ReadableStream} */\n  let stream;\n  return {\n    path: file.name,\n\n    get content() {\n      stream = stream || file.stream();\n      return stream;\n    }\n\n  };\n}\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\n\n\nasync function* paginator(fn, service, opts) {\n  let res = await fn(service, opts);\n  yield res;\n  let link = parseLinkHeader(res.headers.get('Link') || ''); // @ts-ignore\n\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next);\n    yield res;\n    link = parseLinkHeader(res.headers.get('Link') || '');\n  }\n}\n\nexport { Web3Storage, File, Blob, filesFromPath, getFilesFromPath };\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\n\nconst api = Web3Storage;\nvoid api; // eslint-disable-line no-void","map":{"version":3,"sources":["/Users/massimilianoalbini/Documents/gain-drop/node_modules/web3.storage/src/lib.js"],"names":["transform","pRetry","pack","parseLinkHeader","unpackStream","TreewalkCarSplitter","CarReader","filesFromPath","getFilesFromPath","fetch","File","Blob","Blockstore","MAX_PUT_RETRIES","MAX_CONCURRENT_UPLOADS","DEFAULT_CHUNK_SIZE","MAX_BLOCK_SIZE","MAX_CHUNK_SIZE","Web3Storage","constructor","token","endpoint","URL","headers","Error","Authorization","put","files","onRootCidReady","onStoredChunk","maxRetries","maxChunkSize","wrapWithDirectory","name","blockstore","out","root","input","Array","from","map","toImportCandidate","maxChildrenPerNode","toString","car","fromIterable","putCar","close","decoders","targetSize","url","encodeURIComponent","roots","getRoots","length","carRoot","splitter","onCarChunk","carParts","part","push","carFile","type","res","request","method","body","status","json","ok","message","cid","retries","size","upload","_","cars","get","toWeb3Response","delete","console","log","undefined","statusText","list","service","before","Date","toISOString","maxResults","Infinity","listPage","search","URLSearchParams","count","paginator","errorMessage","page","options","opts","toWeb3File","content","path","chunks","chunk","file","toFilenameWithPath","Object","assign","unixFsPath","slashIndex","indexOf","substring","response","unixFsIterator","entry","stream","fn","link","next","api"],"mappings":"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","sourcesContent":["/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables'\nimport pRetry from 'p-retry'\nimport { pack } from 'ipfs-car/pack'\nimport { parseLinkHeader } from '@web3-storage/parse-link-header'\nimport { unpackStream } from 'ipfs-car/unpack'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { CarReader } from '@ipld/car'\nimport { filesFromPath, getFilesFromPath } from 'files-from-path'\nimport {\n  fetch,\n  File,\n  Blob,\n  Blockstore\n} from './platform.js'\n\nconst MAX_PUT_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 10 // chunk to ~10MB CARs\nconst MAX_BLOCK_SIZE = 1048576\nconst MAX_CHUNK_SIZE = 104857600\n\n/** @typedef { import('./lib/interface.js').API } API */\n/** @typedef { import('./lib/interface.js').Status} Status */\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n/** @typedef { import('./lib/interface.js').Service } Service */\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * @implements Service\n */\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n   * @param {{token: string, endpoint?:URL}} options\n   */\n  constructor ({ token, endpoint = new URL('https://api.web3.storage') }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n  static headers (token) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async put ({ endpoint, token }, files, {\n    onRootCidReady,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    wrapWithDirectory = true,\n    name\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const blockstore = new Blockstore()\n    try {\n      const { out, root } = await pack({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      })\n      onRootCidReady && onRootCidReady(root.toString())\n      const car = await CarReader.fromIterable(out)\n      return await Web3Storage.putCar({ endpoint, token }, car, { onStoredChunk, maxRetries, maxChunkSize, name })\n    } finally {\n      await blockstore.close()\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async putCar ({ endpoint, token }, car, {\n    name,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    decoders\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const targetSize = maxChunkSize\n    const url = new URL('car', endpoint)\n    let headers = Web3Storage.headers(token)\n\n    if (name) {\n      headers = { ...headers, 'X-Name': encodeURIComponent(name) }\n    }\n\n    const roots = await car.getRoots()\n    if (roots[0] == null) {\n      throw new Error('missing root CID')\n    }\n    if (roots.length > 1) {\n      throw new Error('too many roots')\n    }\n\n    const carRoot = roots[0].toString()\n    const splitter = new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n    const onCarChunk = async car => {\n      const carParts = []\n      for await (const part of car) {\n        carParts.push(part)\n      }\n\n      const carFile = new Blob(carParts, { type: 'application/car' })\n      const res = await pRetry(\n        async () => {\n          const request = await fetch(url.toString(), {\n            method: 'POST',\n            headers,\n            body: carFile\n          })\n          /* c8 ignore next 3 */\n          if (request.status === 429) {\n            throw new Error('rate limited')\n          }\n          const res = await request.json()\n          if (!request.ok) {\n            throw new Error(res.message)\n          }\n\n          if (res.cid !== carRoot) {\n            throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`)\n          }\n          return res.cid\n        },\n        { retries: maxRetries }\n      )\n\n      onStoredChunk && onStoredChunk(carFile.size)\n      return res\n    }\n\n    const upload = transform(MAX_CONCURRENT_UPLOADS, onCarChunk)\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n    return carRoot\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @returns {Promise<Web3Response | null>}\n   */\n  static async get ({ endpoint, token }, cid) {\n    const url = new URL(`car/${cid}`, endpoint)\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token)\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    return toWeb3Response(res)\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @returns {Promise<CIDString>}\n   */\n  /* c8 ignore next 4 */\n  static async delete ({ endpoint, token }, cid) {\n    console.log('Not deleting', cid, endpoint, token)\n    throw Error('.delete not implemented yet')\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @returns {Promise<Status | undefined>}\n   */\n  static async status ({ endpoint, token }, cid) {\n    const url = new URL(`status/${cid}`, endpoint)\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token)\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    if (res.status === 404) {\n      return undefined\n    }\n    if (!res.ok) {\n      throw new Error(res.statusText)\n    }\n    return res.json()\n  }\n\n  /**\n   * @param {Service} service\n   * @param {object} [opts]\n   * @param {string} [opts.before] list items uploaded before this ISO 8601 date string\n   * @param {number} [opts.maxResults] maximum number of results to return\n   * @returns {AsyncIterable<Upload>}\n   */\n  static async * list (service, { before = new Date().toISOString(), maxResults = Infinity } = {}) {\n  /**\n   * @param {Service} service\n   * @param {{before: string, size: number}} opts\n   * @returns {Promise<Response>}\n   */\n    function listPage ({ endpoint, token }, { before, size }) {\n      const search = new URLSearchParams({ before, size: size.toString() })\n      const url = new URL(`user/uploads?${search}`, endpoint)\n      return fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          ...Web3Storage.headers(token),\n          'Access-Control-Request-Headers': 'Link'\n        }\n      })\n    }\n    let count = 0\n    const size = maxResults > 100 ? 100 : maxResults\n    for await (const res of paginator(listPage, service, { before, size })) {\n      if (!res.ok) {\n        /* c8 ignore next 3 */\n        if (res.status === 429) {\n          throw new Error('rate limited')\n        }\n\n        /* c8 ignore next 2 */\n        const errorMessage = await res.json()\n        throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`)\n      }\n      const page = await res.json()\n      for (const upload of page) {\n        if (++count > maxResults) {\n          return\n        }\n        yield upload\n      }\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n  put (files, options) {\n    return Web3Storage.put(this, files, options)\n  }\n\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n\n   *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n\n   *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n  putCar (car, options) {\n    return Web3Storage.putCar(this, car, options)\n  }\n\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   */\n  get (cid) {\n    return Web3Storage.get(this, cid)\n  }\n\n  /**\n   * @param {CIDString} cid\n   */\n  /* c8 ignore next 3 */\n  delete (cid) {\n    return Web3Storage.delete(this, cid)\n  }\n\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   */\n  status (cid) {\n    return Web3Storage.status(this, cid)\n  }\n\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {object} [opts]\n   * @param {string} [opts.before] list items uploaded before this ISO 8601 date string\n   * @param {number} [opts.maxResults] maximum number of results to return\n   * @returns {AsyncIterable<Upload>}\n   */\n  list (opts) {\n    return Web3Storage.list(this, opts)\n  }\n}\n\n/**\n * Map a UnixFSEntry to a File with a cid property\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\nasync function toWeb3File ({ content, path, cid }) {\n  const chunks = []\n  for await (const chunk of content()) {\n    chunks.push(chunk)\n  }\n  const file = new File(chunks, toFilenameWithPath(path))\n  return Object.assign(file, { cid: cid.toString() })\n}\n\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\nfunction toFilenameWithPath (unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/')\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1)\n}\n\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\nfunction toWeb3Response (res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function * () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`)\n      }\n      /* c8 ignore next 3 */\n      if (!res.body) {\n        throw new Error('No body on response')\n      }\n      const blockstore = new Blockstore()\n      try {\n        for await (const entry of unpackStream(res.body, { blockstore })) {\n          yield entry\n        }\n      } finally {\n        await blockstore.close()\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`)\n      }\n      const files = []\n      // @ts-ignore we're using the enriched response here\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue\n        }\n        const file = await toWeb3File(entry)\n        files.push(file)\n      }\n      return files\n    }\n  })\n  return response\n}\n\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\nfunction toImportCandidate (file) {\n  /** @type {ReadableStream} */\n  let stream\n  return {\n    path: file.name,\n    get content () {\n      stream = stream || file.stream()\n      return stream\n    }\n  }\n}\n\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\nasync function * paginator (fn, service, opts) {\n  let res = await fn(service, opts)\n  yield res\n  let link = parseLinkHeader(res.headers.get('Link') || '')\n  // @ts-ignore\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next)\n    yield res\n    link = parseLinkHeader(res.headers.get('Link') || '')\n  }\n}\n\nexport { Web3Storage, File, Blob, filesFromPath, getFilesFromPath }\n\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\nconst api = Web3Storage\nvoid api // eslint-disable-line no-void\n"]},"metadata":{},"sourceType":"module"}