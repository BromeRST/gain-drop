{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransportDelegate = void 0;\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst keepkey = __importStar(require(\"@shapeshiftoss/hdwallet-keepkey\"));\n\nconst utils_1 = require(\"./utils\");\n\nclass TransportDelegate {\n  constructor(usbDevice) {\n    if (usbDevice.vendorId !== utils_1.VENDOR_ID) throw new core.WebUSBCouldNotPair(\"KeepKey\", \"bad vendor id\");\n    if (usbDevice.productId !== utils_1.WEBUSB_PRODUCT_ID) throw new core.FirmwareUpdateRequired(\"KeepKey\", \"6.1.0\");\n    this.usbDevice = usbDevice;\n  }\n\n  static create(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (device.vendorId !== utils_1.VENDOR_ID) return null;\n      return new TransportDelegate(device);\n    });\n  }\n\n  getDeviceID() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.usbDevice.serialNumber;\n    });\n  }\n\n  isOpened() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.usbDevice.opened;\n    });\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.usbDevice.open();\n      if (this.usbDevice.configuration === null) yield this.usbDevice.selectConfiguration(1);\n\n      try {\n        yield this.usbDevice.claimInterface(0);\n      } catch (e) {\n        console.error(\"Could not claim interface 0\", this.usbDevice, {\n          e\n        });\n        if (core.isIndexable(e) && e.code === 18) // \"The requested interface implements a protected class\"\n          throw new core.FirmwareUpdateRequired(\"KeepKey\", \"6.1.0\");\n        if (core.isIndexable(e) && e.code === 19) // \"Unable to claim interface\"\n          throw new core.ConflictingApp(\"KeepKey\");\n        throw e;\n      }\n    });\n  }\n\n  tryConnectDebugLink() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // We have to use \"guess & check\" here because the browser doesn't give us a\n      // way to inspect the descriptors :(\n      try {\n        yield this.usbDevice.claimInterface(1);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.usbDevice.opened) return;\n\n      try {\n        // If the device is disconnected, this will fail and throw, which is fine.\n        yield this.usbDevice.close();\n      } catch (e) {\n        console.log(\"Error closing connection with usbDevice\");\n      }\n    });\n  }\n\n  writeChunk(buf, debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.usbDevice.transferOut(debugLink ? 2 : 1, buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n    });\n  }\n\n  readChunk(debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        status,\n        data\n      } = yield this.usbDevice.transferIn(debugLink ? 2 : 1, keepkey.SEGMENT_SIZE + 1);\n\n      if (status === \"stall\") {\n        yield this.usbDevice.clearHalt(\"out\", debugLink ? 2 : 1);\n      }\n\n      if (data === undefined) throw new Error(\"bad read\");\n      return new Uint8Array(core.toArrayBuffer(data));\n    });\n  }\n\n}\n\nexports.TransportDelegate = TransportDelegate;","map":{"version":3,"mappings":"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","names":["TransportDelegate","constructor","usbDevice","vendorId","utils_1","core","WebUSBCouldNotPair","productId","FirmwareUpdateRequired","create","device","getDeviceID","serialNumber","isOpened","opened","connect","open","configuration","selectConfiguration","claimInterface","e","console","error","isIndexable","code","ConflictingApp","tryConnectDebugLink","disconnect","close","log","writeChunk","buf","debugLink","transferOut","buffer","slice","byteOffset","byteLength","readChunk","status","data","transferIn","keepkey","SEGMENT_SIZE","clearHalt","undefined","Error","Uint8Array","toArrayBuffer","exports"],"sourceRoot":"","sources":["../src/transport.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}