{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst baddress = require('./address');\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst classify = require('./classify');\n\nconst bcrypto = require('./crypto');\n\nconst ECPair = require('./ecpair');\n\nconst networks = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst script_1 = require('./script');\n\nconst transaction_1 = require('./transaction');\n\nconst types = require('./types');\n\nconst typeforce = require('typeforce');\n\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([// Raw\n'p2pkh', 'p2pk', 'p2wpkh', 'p2ms', // P2SH wrapped\n'p2sh-p2pkh', 'p2sh-p2pk', 'p2sh-p2wpkh', 'p2sh-p2ms', // P2WSH wrapped\n'p2wsh-p2pkh', 'p2wsh-p2pk', 'p2wsh-p2ms', // P2SH-P2WSH wrapper\n'p2sh-p2wsh-p2pkh', 'p2sh-p2wsh-p2pk', 'p2sh-p2wsh-p2ms']);\n\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\n\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\n\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\n\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor() {\n    let network = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : networks.bitcoin;\n    let maximumFeeRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2500;\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__BITCOINCASH = false;\n    this.__BITCOINGOLD = false;\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn('Deprecation Warning: TransactionBuilder will be removed in the future. ' + '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' + 'are available in the transactions-psbt.js integration test file on our ' + 'Github. A high level explanation is available in the psbt.ts and psbt.js ' + 'files as well.');\n  }\n\n  static fromTransaction(transaction, network, forkId) {\n    const txb = new TransactionBuilder(network);\n\n    if (typeof forkId === 'number') {\n      if (forkId === transaction_1.Transaction.FORKID_BTG) {\n        txb.enableBitcoinGold(true);\n      } else if (forkId === transaction_1.Transaction.FORKID_BCH) {\n        txb.enableBitcoinCash(true);\n      }\n    } // Copy transaction fields\n\n\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime); // Copy outputs (done first to avoid signature invalidation)\n\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    }); // Copy inputs\n\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n        value: txIn.value\n      });\n    }); // fix some things not possible through the public API\n\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i, input.value, forkId);\n    });\n\n    return txb;\n  }\n\n  enableBitcoinCash(enable) {\n    if (typeof enable === 'undefined') {\n      enable = true;\n    }\n\n    this.__BITCOINCASH = enable;\n  }\n\n  enableBitcoinGold(enable) {\n    if (typeof enable === 'undefined') {\n      enable = true;\n    }\n\n    this.__BITCOINGOLD = enable;\n  }\n\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n\n    if (setting === undefined) {\n      setting = true;\n    }\n\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n    if (this.__INPUTS.some(input => {\n      if (!input.signatures) return false;\n      return input.signatures.some(s => s !== undefined);\n    })) {\n      throw new Error('No, this would invalidate signatures');\n    }\n\n    this.__TX.locktime = locktime;\n  }\n\n  setVersion(version) {\n    typeforce(types.UInt32, version); // XXX: this might eventually become more complex depending on what the versions represent\n\n    this.__TX.version = version;\n  }\n\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n\n    let value; // is it a hex string?\n\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex')); // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value\n    });\n  }\n\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    } // Attempt to get a script if it's a base58 or bech32 address string\n\n\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n\n  build() {\n    return this.__build(false);\n  }\n\n  buildIncomplete() {\n    return this.__build(true);\n  }\n\n  sign(signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n    trySign(getSigningData(this.network, this.__INPUTS, this.__needsOutputs.bind(this), this.__TX, signParams, {\n      btg: this.__BITCOINGOLD,\n      bch: this.__BITCOINCASH\n    }, keyPair, redeemScript, hashType, witnessValue, witnessScript, this.__USE_LOW_R));\n  }\n\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {}; // derive what we can from the scriptSig\n\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    } // if an input value was given, retain it\n\n\n    if (options.value !== undefined) {\n      input.value = options.value;\n    } // derive what we can from the previous transactions output script\n\n\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n\n        prevOutType = expanded.type;\n      }\n\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n\n    const vin = this.__TX.addInput(txHash, vout, options.sequence, options.scriptSig);\n\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n\n    const tx = this.__TX.clone(); // create script signatures from inputs\n\n\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete) throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD) throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n\n    return tx;\n  }\n\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n\n        return (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0;\n      });\n    });\n  }\n\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    } // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n\n\n    return this.__TX.outs.length === 0 && this.__INPUTS.some(input => {\n      if (!input.signatures) return false;\n      return input.signatures.some(signature => {\n        if (!signature) return false; // no signature, no issue\n\n        const hashType = signatureHashType(signature);\n        if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n\n        return true; // SIGHASH_* does care\n      });\n    });\n  }\n\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n\n        return false;\n      });\n    });\n  }\n\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0); // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n\n\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n\n}\n\nexports.TransactionBuilder = TransactionBuilder;\n\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        const {\n          output,\n          pubkey,\n          signature\n        } = payments.p2wpkh({\n          witness: witnessStack\n        });\n        return {\n          prevOutScript: output,\n          prevOutType: SCRIPT_TYPES.P2WPKH,\n          pubkeys: [pubkey],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PKH:\n      {\n        const {\n          output,\n          pubkey,\n          signature\n        } = payments.p2pkh({\n          input: scriptSig\n        });\n        return {\n          prevOutScript: output,\n          prevOutType: SCRIPT_TYPES.P2PKH,\n          pubkeys: [pubkey],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        const {\n          signature\n        } = payments.p2pk({\n          input: scriptSig\n        });\n        return {\n          prevOutType: SCRIPT_TYPES.P2PK,\n          pubkeys: [undefined],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        const {\n          m,\n          pubkeys,\n          signatures\n        } = payments.p2ms({\n          input: scriptSig,\n          output: scriptPubKey\n        }, {\n          allowIncomplete: true\n        });\n        return {\n          prevOutType: SCRIPT_TYPES.P2MS,\n          pubkeys,\n          signatures,\n          maxSignatures: m\n        };\n      }\n  }\n\n  if (type === SCRIPT_TYPES.P2SH) {\n    const {\n      output,\n      redeem\n    } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(redeem.input, redeem.witness, outputType, redeem.output);\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    };\n  }\n\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const {\n      output,\n      redeem\n    } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(bscript.compile(redeem.witness), [], outputType, redeem.output);\n    }\n\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    };\n  }\n\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig\n  };\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin, value, forkId) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript) return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match; // check for a signature\n\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      const parsed = bscript.signature.decode(signature);\n      let hash;\n\n      switch (forkId) {\n        case transaction_1.Transaction.FORKID_BCH:\n          hash = transaction.hashForCashSignature(vin, input.redeemScript, value, parsed.hashType);\n          break;\n\n        case transaction_1.Transaction.FORKID_BTG:\n          hash = transaction.hashForGoldSignature(vin, input.redeemScript, value, parsed.hashType);\n          break;\n\n        default:\n          if (input.witness) {\n            hash = transaction.hashForWitnessV0(vin, input.redeemScript, value, parsed.hashType);\n          } else {\n            hash = transaction.hashForSignature(vin, input.redeemScript, parsed.hashType);\n          }\n\n          break;\n      } // skip if signature does not match pubKey\n\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH:\n      {\n        if (!ourPubKey) return {\n          type\n        }; // does our hash160(pubKey) match the output scripts?\n\n        const pkh1 = payments.p2pkh({\n          output: script\n        }).hash;\n        const pkh2 = bcrypto.hash160(ourPubKey);\n        if (!pkh1.equals(pkh2)) return {\n          type\n        };\n        return {\n          type,\n          pubkeys: [ourPubKey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        if (!ourPubKey) return {\n          type\n        }; // does our hash160(pubKey) match the output scripts?\n\n        const wpkh1 = payments.p2wpkh({\n          output: script\n        }).hash;\n        const wpkh2 = bcrypto.hash160(ourPubKey);\n        if (!wpkh1.equals(wpkh2)) return {\n          type\n        };\n        return {\n          type,\n          pubkeys: [ourPubKey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        const p2pk = payments.p2pk({\n          output: script\n        });\n        return {\n          type,\n          pubkeys: [p2pk.pubkey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        const p2ms = payments.p2ms({\n          output: script\n        });\n        return {\n          type,\n          pubkeys: p2ms.pubkeys,\n          signatures: p2ms.pubkeys.map(() => undefined),\n          maxSignatures: p2ms.m\n        };\n      }\n  }\n\n  return {\n    type\n  };\n}\n\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: {\n        output: witnessScript\n      }\n    });\n    const p2wshAlt = payments.p2wsh({\n      output: redeemScript\n    });\n    const p2sh = payments.p2sh({\n      redeem: {\n        output: redeemScript\n      }\n    });\n    const p2shAlt = payments.p2sh({\n      redeem: p2wsh\n    }); // enforces P2SH(P2WSH(...))\n\n    if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (redeemScript) {\n    const p2sh = payments.p2sh({\n      redeem: {\n        output: redeemScript\n      }\n    });\n\n    if (input.prevOutScript) {\n      let p2shAlt;\n\n      try {\n        p2shAlt = payments.p2sh({\n          output: input.prevOutScript\n        });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n\n      if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as redeemScript (' + bscript.toASM(redeemScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    let signScript = redeemScript;\n\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({\n        pubkey: expanded.pubkeys[0]\n      }).output;\n    }\n\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: {\n        output: witnessScript\n      }\n    });\n\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({\n        output: input.prevOutScript\n      });\n      if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript');\n    }\n\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires witnessScript');\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported (' + bscript.toASM(input.prevOutScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    let signScript = input.prevOutScript;\n\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({\n        pubkey: expanded.pubkeys[0]\n      }).output;\n    }\n\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  const prevOutScript = payments.p2pkh({\n    pubkey: ourPubKey\n  }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined]\n  };\n}\n\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2pkh({\n          pubkey: pubkeys[0],\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2wpkh({\n          pubkey: pubkeys[0],\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2pk({\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        const m = input.maxSignatures;\n\n        if (allowIncomplete) {\n          signatures = signatures.map(x => x || script_1.OPS.OP_0);\n        } else {\n          signatures = signatures.filter(x => x);\n        } // if the transaction is not not complete (complete), or if signatures.length === m, validate\n        // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n\n\n        const validate = !allowIncomplete || m === signatures.length;\n        return payments.p2ms({\n          m,\n          pubkeys,\n          signatures\n        }, {\n          allowIncomplete,\n          validate\n        });\n      }\n\n    case SCRIPT_TYPES.P2SH:\n      {\n        const redeem = build(input.redeemScriptType, input, allowIncomplete);\n        if (!redeem) return;\n        return payments.p2sh({\n          redeem: {\n            output: redeem.output || input.redeemScript,\n            input: redeem.input,\n            witness: redeem.witness\n          }\n        });\n      }\n\n    case SCRIPT_TYPES.P2WSH:\n      {\n        const redeem = build(input.witnessScriptType, input, allowIncomplete);\n        if (!redeem) return;\n        return payments.p2wsh({\n          redeem: {\n            output: input.witnessScript,\n            input: redeem.input,\n            witness: redeem.witness\n          }\n        });\n      }\n  }\n}\n\nfunction canSign(input) {\n  return input.signScript !== undefined && input.signType !== undefined && input.pubkeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubkeys.length && input.pubkeys.length > 0 && (input.hasWitness === false || input.value !== undefined);\n}\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(`Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`);\n  }\n\n  tfMessage(typeforce.Number, signParams.vin, `sign must include vin parameter as Number (input index)`);\n  tfMessage(types.Signer, signParams.keyPair, `sign must include keyPair parameter as Signer interface`);\n  tfMessage(typeforce.maybe(typeforce.Number), signParams.hashType, `sign hashType parameter must be a number`);\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(`input #${signParams.vin} is not of type p2pkh: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);\n      break;\n\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(`input #${signParams.vin} is not of type p2pk: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);\n      break;\n\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(`input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);\n      tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessValue`);\n      break;\n\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(`input #${signParams.vin} is not of type p2ms: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);\n      break;\n\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(`input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);\n      tfMessage(typeforce.Buffer, signParams.redeemScript, `${posType} requires redeemScript`);\n      tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessValue`);\n      break;\n\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(`input #${signParams.vin} is not of type ${posType}: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, `${posType} requires NO witnessScript`);\n      tfMessage(typeforce.Buffer, signParams.redeemScript, `${posType} requires redeemScript`);\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, `${posType} requires NO witnessValue`);\n      break;\n\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(`input #${signParams.vin} is not of type ${posType}: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.Buffer, signParams.witnessScript, `${posType} requires witnessScript`);\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, `${posType} requires NO redeemScript`);\n      tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessValue`);\n      break;\n\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(`input #${signParams.vin} is not of type ${posType}: ${prevOutType}`);\n      }\n\n      tfMessage(typeforce.Buffer, signParams.witnessScript, `${posType} requires witnessScript`);\n      tfMessage(typeforce.Buffer, signParams.redeemScript, `${posType} requires witnessScript`);\n      tfMessage(types.Satoshi, signParams.witnessValue, `${posType} requires witnessScript`);\n      break;\n  }\n}\n\nfunction trySign(_ref) {\n  let {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR\n  } = _ref;\n  // enforce in order signing of public keys\n  let signed = false;\n\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists'); // TODO: add tests\n\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    }\n\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\n\nfunction getSigningData(network, inputs, needsOutputs, tx, signParams, forkBools, keyPair, redeemScript, hashType, witnessValue, witnessScript, useLowR) {\n  let vin;\n\n  if (typeof signParams === 'number') {\n    console.warn('DEPRECATED: TransactionBuilder sign method arguments ' + 'will change in v6, please use the TxbSignArg interface');\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript\n    } = signParams);\n  } else {\n    throw new TypeError('TransactionBuilder sign first arg must be TxbSignArg or number');\n  }\n\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  } // TODO: remove keyPair.network matching in 4.0.0\n\n\n  if (keyPair.network && keyPair.network !== network) throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  const ourPubKey = keyPair.publicKey || keyPair.getPublicKey && keyPair.getPublicKey();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    if (!canSign(input)) {\n      const prepared = prepareInput(input, ourPubKey, redeemScript, witnessScript); // updates inline\n\n      Object.assign(input, prepared);\n    }\n\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n\n\n  let signatureHash;\n\n  if (forkBools.btg) {\n    signatureHash = tx.hashForGoldSignature(vin, input.signScript, input.value, hashType, !!input.witness);\n  } else if (forkBools.bch) {\n    signatureHash = tx.hashForCashSignature(vin, input.signScript, input.value, hashType);\n  } else {\n    if (input.hasWitness) {\n      signatureHash = tx.hashForWitnessV0(vin, input.signScript, input.value, hashType);\n    } else {\n      signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n    }\n  }\n\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR\n  };\n}","map":{"version":3,"sources":["/Users/massimilianoalbini/Documents/gain-drop/gain-drop/node_modules/@shapeshiftoss/bitcoinjs-lib/src/transaction_builder.js"],"names":["Object","defineProperty","exports","value","baddress","require","bufferutils_1","classify","bcrypto","ECPair","networks","payments","bscript","script_1","transaction_1","types","typeforce","SCRIPT_TYPES","PREVOUT_TYPES","Set","tfMessage","type","message","err","Error","txIsString","tx","String","txIsTransaction","Transaction","TransactionBuilder","constructor","network","bitcoin","maximumFeeRate","__PREV_TX_SET","__INPUTS","__BITCOINCASH","__BITCOINGOLD","__TX","version","__USE_LOW_R","console","warn","fromTransaction","transaction","forkId","txb","FORKID_BTG","enableBitcoinGold","FORKID_BCH","enableBitcoinCash","setVersion","setLockTime","locktime","outs","forEach","txOut","addOutput","script","ins","txIn","__addInputUnsafe","hash","index","sequence","witness","input","i","fixMultisigOrder","enable","setLowR","setting","maybe","Boolean","undefined","UInt32","some","signatures","s","addInput","txHash","vout","prevOutScript","__canModifyInputs","reverseBuffer","Buffer","from","getHash","scriptPubKey","__canModifyOutputs","toOutputScript","build","__build","buildIncomplete","sign","signParams","keyPair","redeemScript","hashType","witnessValue","witnessScript","trySign","getSigningData","__needsOutputs","bind","btg","bch","options","isCoinbaseHash","prevTxOut","toString","expandInput","prevOutType","pubkeys","expanded","expandOutput","output","vin","scriptSig","allowIncomplete","length","clone","result","NONSTANDARD","setInputScript","setWitness","__overMaximumFees","virtualSize","every","signature","signatureHashType","SIGHASH_ANYONECANPAY","signingHashType","SIGHASH_ALL","SIGHASH_NONE","nInputs","nOutputs","hashTypeMod","SIGHASH_SINGLE","bytes","incoming","reduce","a","x","outgoing","fee","feeRate","witnessStack","ssType","wsType","P2WPKH","pubkey","p2wpkh","P2PKH","p2pkh","P2PK","p2pk","P2MS","m","p2ms","maxSignatures","P2SH","redeem","p2sh","outputType","redeemScriptType","witnessScriptType","P2WSH","p2wsh","compile","unmatched","concat","map","pubKey","fromPublicKey","match","parsed","decode","hashForCashSignature","hashForGoldSignature","hashForWitnessV0","hashForSignature","verify","ourPubKey","pkh1","pkh2","hash160","equals","wpkh1","wpkh2","prepareInput","p2wshAlt","p2shAlt","toASM","signScript","hasWitness","signType","e","OPS","OP_0","filter","validate","canSign","buffer","readUInt8","checkSignArgs","inputs","has","prevOutScriptType","TypeError","Number","Signer","posType","Satoshi","signatureHash","useLowR","signed","entries","encode","needsOutputs","forkBools","publicKey","getPublicKey","prepared","assign"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst baddress = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst classify = require('./classify');\nconst bcrypto = require('./crypto');\nconst ECPair = require('./ecpair');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([\n  // Raw\n  'p2pkh',\n  'p2pk',\n  'p2wpkh',\n  'p2ms',\n  // P2SH wrapped\n  'p2sh-p2pkh',\n  'p2sh-p2pk',\n  'p2sh-p2wpkh',\n  'p2sh-p2ms',\n  // P2WSH wrapped\n  'p2wsh-p2pkh',\n  'p2wsh-p2pk',\n  'p2wsh-p2ms',\n  // P2SH-P2WSH wrapper\n  'p2sh-p2wsh-p2pkh',\n  'p2sh-p2wsh-p2pk',\n  'p2sh-p2wsh-p2ms',\n]);\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__BITCOINCASH = false;\n    this.__BITCOINGOLD = false;\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn(\n      'Deprecation Warning: TransactionBuilder will be removed in the future. ' +\n        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +\n        'are available in the transactions-psbt.js integration test file on our ' +\n        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +\n        'files as well.',\n    );\n  }\n  static fromTransaction(transaction, network, forkId) {\n    const txb = new TransactionBuilder(network);\n    if (typeof forkId === 'number') {\n      if (forkId === transaction_1.Transaction.FORKID_BTG) {\n        txb.enableBitcoinGold(true);\n      } else if (forkId === transaction_1.Transaction.FORKID_BCH) {\n        txb.enableBitcoinCash(true);\n      }\n    }\n    // Copy transaction fields\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime);\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n        value: txIn.value,\n      });\n    });\n    // fix some things not possible through the public API\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i, input.value, forkId);\n    });\n    return txb;\n  }\n  enableBitcoinCash(enable) {\n    if (typeof enable === 'undefined') {\n      enable = true;\n    }\n    this.__BITCOINCASH = enable;\n  }\n  enableBitcoinGold(enable) {\n    if (typeof enable === 'undefined') {\n      enable = true;\n    }\n    this.__BITCOINGOLD = enable;\n  }\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n    if (setting === undefined) {\n      setting = true;\n    }\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(s => s !== undefined);\n      })\n    ) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    this.__TX.locktime = locktime;\n  }\n  setVersion(version) {\n    typeforce(types.UInt32, version);\n    // XXX: this might eventually become more complex depending on what the versions represent\n    this.__TX.version = version;\n  }\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    let value;\n    // is it a hex string?\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));\n      // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value,\n    });\n  }\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 or bech32 address string\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n  build() {\n    return this.__build(false);\n  }\n  buildIncomplete() {\n    return this.__build(true);\n  }\n  sign(\n    signParams,\n    keyPair,\n    redeemScript,\n    hashType,\n    witnessValue,\n    witnessScript,\n  ) {\n    trySign(\n      getSigningData(\n        this.network,\n        this.__INPUTS,\n        this.__needsOutputs.bind(this),\n        this.__TX,\n        signParams,\n        {\n          btg: this.__BITCOINGOLD,\n          bch: this.__BITCOINCASH,\n        },\n        keyPair,\n        redeemScript,\n        hashType,\n        witnessValue,\n        witnessScript,\n        this.__USE_LOW_R,\n      ),\n    );\n  }\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined)\n      throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n      input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n        prevOutType = expanded.type;\n      }\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n    const vin = this.__TX.addInput(\n      txHash,\n      vout,\n      options.sequence,\n      options.scriptSig,\n    );\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n    const tx = this.__TX.clone();\n    // create script signatures from inputs\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete)\n        throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)\n          throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n    return tx;\n  }\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n        return (\n          (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0\n        );\n      });\n    });\n  }\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    }\n    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n    return (\n      this.__TX.outs.length === 0 &&\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(signature => {\n          if (!signature) return false; // no signature, no issue\n          const hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n          return true; // SIGHASH_* does care\n        });\n      })\n    );\n  }\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n        return false;\n      });\n    });\n  }\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n}\nexports.TransactionBuilder = TransactionBuilder;\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({\n        witness: witnessStack,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({\n        input: scriptSig,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig });\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms(\n        {\n          input: scriptSig,\n          output: scriptPubKey,\n        },\n        { allowIncomplete: true },\n      );\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys,\n        signatures,\n        maxSignatures: m,\n      };\n    }\n  }\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(\n      redeem.input,\n      redeem.witness,\n      outputType,\n      redeem.output,\n    );\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(\n        bscript.compile(redeem.witness),\n        [],\n        outputType,\n        redeem.output,\n      );\n    }\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig,\n  };\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin, value, forkId) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)\n    return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match;\n    // check for a signature\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature);\n      let hash;\n      switch (forkId) {\n        case transaction_1.Transaction.FORKID_BCH:\n          hash = transaction.hashForCashSignature(\n            vin,\n            input.redeemScript,\n            value,\n            parsed.hashType,\n          );\n          break;\n        case transaction_1.Transaction.FORKID_BTG:\n          hash = transaction.hashForGoldSignature(\n            vin,\n            input.redeemScript,\n            value,\n            parsed.hashType,\n          );\n          break;\n        default:\n          if (input.witness) {\n            hash = transaction.hashForWitnessV0(\n              vin,\n              input.redeemScript,\n              value,\n              parsed.hashType,\n            );\n          } else {\n            hash = transaction.hashForSignature(\n              vin,\n              input.redeemScript,\n              parsed.hashType,\n            );\n          }\n          break;\n      }\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash;\n      const pkh2 = bcrypto.hash160(ourPubKey);\n      if (!pkh1.equals(pkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash;\n      const wpkh2 = bcrypto.hash160(ourPubKey);\n      if (!wpkh1.equals(wpkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script });\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script });\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m,\n      };\n    }\n  }\n  return { type };\n}\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: witnessScript },\n    });\n    const p2wshAlt = payments.p2wsh({ output: redeemScript });\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    const p2shAlt = payments.p2sh({ redeem: p2wsh });\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash))\n      throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash))\n      throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    if (input.prevOutScript) {\n      let p2shAlt;\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n      if (!p2sh.hash.equals(p2shAlt.hash))\n        throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as redeemScript (' +\n          bscript.toASM(redeemScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = redeemScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });\n      if (!p2wsh.hash.equals(p2wshAlt.hash))\n        throw new Error('Witness script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',\n      );\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',\n      );\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported (' +\n          bscript.toASM(input.prevOutScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = input.prevOutScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined],\n  };\n}\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pk({ signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures;\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || script_1.OPS.OP_0);\n      } else {\n        signatures = signatures.filter(x => x);\n      }\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || m === signatures.length;\n      return payments.p2ms(\n        { m, pubkeys, signatures },\n        { allowIncomplete, validate },\n      );\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n  }\n}\nfunction canSign(input) {\n  return (\n    input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (input.hasWitness === false || input.value !== undefined)\n  );\n}\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\n      `Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`,\n    );\n  }\n  tfMessage(\n    typeforce.Number,\n    signParams.vin,\n    `sign must include vin parameter as Number (input index)`,\n  );\n  tfMessage(\n    types.Signer,\n    signParams.keyPair,\n    `sign must include keyPair parameter as Signer interface`,\n  );\n  tfMessage(\n    typeforce.maybe(typeforce.Number),\n    signParams.hashType,\n    `sign hashType parameter must be a number`,\n  );\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessScript`,\n      );\n      break;\n  }\n}\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR,\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error(\n        'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',\n      );\n    }\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\nfunction getSigningData(\n  network,\n  inputs,\n  needsOutputs,\n  tx,\n  signParams,\n  forkBools,\n  keyPair,\n  redeemScript,\n  hashType,\n  witnessValue,\n  witnessScript,\n  useLowR,\n) {\n  let vin;\n  if (typeof signParams === 'number') {\n    console.warn(\n      'DEPRECATED: TransactionBuilder sign method arguments ' +\n        'will change in v6, please use the TxbSignArg interface',\n    );\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript,\n    } = signParams);\n  } else {\n    throw new TypeError(\n      'TransactionBuilder sign first arg must be TxbSignArg or number',\n    );\n  }\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  }\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== network)\n    throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (\n    input.redeemScript !== undefined &&\n    redeemScript &&\n    !input.redeemScript.equals(redeemScript)\n  ) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  const ourPubKey =\n    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue)\n        throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    if (!canSign(input)) {\n      const prepared = prepareInput(\n        input,\n        ourPubKey,\n        redeemScript,\n        witnessScript,\n      );\n      // updates inline\n      Object.assign(input, prepared);\n    }\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  let signatureHash;\n  if (forkBools.btg) {\n    signatureHash = tx.hashForGoldSignature(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n      !!input.witness,\n    );\n  } else if (forkBools.bch) {\n    signatureHash = tx.hashForCashSignature(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n    );\n  } else {\n    if (input.hasWitness) {\n      signatureHash = tx.hashForWitnessV0(\n        vin,\n        input.signScript,\n        input.value,\n        hashType,\n      );\n    } else {\n      signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n    }\n  }\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}