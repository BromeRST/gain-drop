{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst errors_1 = require(\"./errors\");\n\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n\n  get indexes() {\n    return this._indexes;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n\n}\n\nexports.FountainDecoderPart = FountainDecoderPart;\n\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    } // This part should be processed\n\n\n    return true;\n  }\n\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(_ref => {\n      let {\n        value: mixedPart\n      } = _ref;\n      return this.reducePartByPart(mixedPart, part);\n    }).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex); // If we've received all the parts\n\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(_ref3 => {\n      let {\n        key: indexes\n      } = _ref3;\n      return utils_1.arraysEqual(indexes, part.indexes);\n    })) {\n      return;\n    } // Reduce this part by all the others\n\n\n    let p2 = this.simpleParts.reduce((acc, _ref4) => {\n      let {\n        value: p\n      } = _ref4;\n      return this.reducePartByPart(acc, p);\n    }, part);\n    p2 = this.mixedParts.reduce((acc, _ref5) => {\n      let {\n        value: p\n      } = _ref5;\n      return this.reducePartByPart(acc, p);\n    }, p2); // If the part is now simple\n\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift();\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n\n  isFailure() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    } // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n\n\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n\n}\n\nexports.default = FountainDecoder;\n\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"mappings":"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","names":["FountainDecoderPart","constructor","_indexes","_fragment","indexes","fragment","fromEncoderPart","encoderPart","fountainUtils_1","seqNum","seqLength","checksum","isSimple","length","exports","FountainDecoder","undefined","validatePart","part","expectedPartIndexes","Array","forEach","_","index","push","expectedMessageLength","messageLength","expectedChecksum","expectedFragmentLength","reducePartByPart","a","b","utils_1","newIndexes","newFragment","reduceMixedBy","newMixed","mixedParts","map","value","mixedPart","reducedPart","queuedParts","key","processSimplePart","fragmentIndex","receivedPartIndexes","includes","simpleParts","sortedParts","sort","message","joinFragments","result","error","errors_1","processMixedPart","some","p2","reduce","acc","p","processQueuedItem","shift","receivePart","isComplete","decoderPart","lastPartIndexes","processedPartsCount","Boolean","isSuccess","resultMessage","Buffer","from","isFailure","resultError","expectedPartCount","getExpectedPartIndexes","getReceivedPartIndexes","getLastPartIndexes","estimatedPercentComplete","Math","min","getProgress","fragments","concat","slice"],"sourceRoot":"","sources":["../src/fountainDecoder.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}