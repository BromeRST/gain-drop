{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeUR = void 0;\n\nvar miniCbor_1 = require(\"./miniCbor\");\n\nvar bc_bech32_1 = require(\"@cvbb/bc-bech32\");\n\nvar utils_1 = require(\"./utils\");\n\nvar composeUR = function (payload, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  return \"ur:\" + type + \"/\" + payload;\n};\n\nvar composeDigest = function (payload, digest) {\n  return digest + \"/\" + payload;\n};\n\nvar composeSequencing = function (payload, index, total) {\n  return index + 1 + \"of\" + total + \"/\" + payload;\n};\n\nvar composeHeadersToFragments = function (fragments, digest, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  if (fragments.length === 1) {\n    return [composeUR(fragments[0])];\n  } else {\n    return fragments.map(function (f, index) {\n      return utils_1.compose3(function (payload) {\n        return composeUR(payload, type);\n      }, function (payload) {\n        return composeSequencing(payload, index, fragments.length);\n      }, function (payload) {\n        return composeDigest(payload, digest);\n      })(f);\n    });\n  }\n};\n\nvar encodeUR = function (payload, fragmentCapacity) {\n  if (fragmentCapacity === void 0) {\n    fragmentCapacity = 200;\n  }\n\n  var cborPayload = miniCbor_1.encodeSimpleCBOR(payload);\n  var bc32Payload = bc_bech32_1.encodeBc32Data(cborPayload);\n  var digest = utils_1.sha256Hash(Buffer.from(cborPayload, 'hex')).toString('hex');\n  var bc32Digest = bc_bech32_1.encodeBc32Data(digest);\n  var fragments = bc32Payload.match(new RegExp('.{1,' + fragmentCapacity + '}', 'g'));\n\n  if (!fragments) {\n    throw new Error('Unexpected error when encoding');\n  }\n\n  return composeHeadersToFragments(fragments, bc32Digest, 'bytes').map(function (str) {\n    return str.toUpperCase();\n  });\n};\n\nexports.encodeUR = encodeUR;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA,IAAMA,SAAS,GAAG,UAACC,OAAD,EAAkBC,IAAlB,EAAgC;AAAd;AAAAA;AAAc;;AAC9C,SAAO,QAAMA,IAAN,GAAU,GAAV,GAAcD,OAArB;AACH,CAFD;;AAIA,IAAME,aAAa,GAAG,UAACF,OAAD,EAAkBG,MAAlB,EAAgC;AAClD,SAAUA,MAAM,MAAN,GAAUH,OAApB;AACH,CAFD;;AAIA,IAAMI,iBAAiB,GAAG,UAACJ,OAAD,EAAkBK,KAAlB,EAAiCC,KAAjC,EAA8C;AACpE,SAAUD,KAAK,GAAG,CAAR,GAAS,IAAT,GAAcC,KAAd,GAAmB,GAAnB,GAAuBN,OAAjC;AACH,CAFD;;AAIA,IAAMO,yBAAyB,GAAG,UAACC,SAAD,EAAsBL,MAAtB,EAAsCF,IAAtC,EAAoD;AAAd;AAAAA;AAAc;;AAClF,MAAIO,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;AACxB,WAAO,CAACV,SAAS,CAACS,SAAS,CAAC,CAAD,CAAV,CAAV,CAAP;AACH,GAFD,MAEO;AACH,WAAOA,SAAS,CAACE,GAAV,CAAc,UAACC,CAAD,EAAIN,KAAJ,EAAS;AAC1B,aAAOO,iBACH,UAACZ,OAAD,EAAgB;AAAK,wBAAS,CAACA,OAAD,EAAUC,IAAV,CAAT;AAAwB,OAD1C,EAEH,UAACD,OAAD,EAAgB;AAAK,gCAAiB,CAACA,OAAD,EAAUK,KAAV,EAAiBG,SAAS,CAACC,MAA3B,CAAjB;AAAmD,OAFrE,EAGH,UAACT,OAAD,EAAgB;AAAK,4BAAa,CAACA,OAAD,EAAUG,MAAV,CAAb;AAA8B,OAHhD,EAILQ,CAJK,CAAP;AAKH,KANM,CAAP;AAOH;AACJ,CAZD;;AAcO,IAAME,QAAQ,GAAG,UAACb,OAAD,EAAkBc,gBAAlB,EAAwC;AAAtB;AAAAA;AAAsB;;AAC5D,MAAMC,WAAW,GAAGC,4BAAiBhB,OAAjB,CAApB;AACA,MAAMiB,WAAW,GAAGC,2BAAeH,WAAf,CAApB;AACA,MAAMZ,MAAM,GAAGS,mBAAWO,MAAM,CAACC,IAAP,CAAYL,WAAZ,EAAyB,KAAzB,CAAX,EAA4CM,QAA5C,CAAqD,KAArD,CAAf;AACA,MAAMC,UAAU,GAAGJ,2BAAef,MAAf,CAAnB;AACA,MAAMK,SAAS,GAAGS,WAAW,CAACM,KAAZ,CAAkB,IAAIC,MAAJ,CAAW,SAASV,gBAAT,GAA4B,GAAvC,EAA4C,GAA5C,CAAlB,CAAlB;;AACA,MAAI,CAACN,SAAL,EAAgB;AACZ,UAAM,IAAIiB,KAAJ,CAAU,gCAAV,CAAN;AACH;;AACD,SAAOlB,yBAAyB,CAACC,SAAD,EAAYc,UAAZ,EAAwB,OAAxB,CAAzB,CAA0DZ,GAA1D,CAA8D,UAACgB,GAAD,EAAI;AAAK,cAAG,CAACC,WAAJ;AAAiB,GAAxF,CAAP;AACH,CAVM;;AAAMC,mBAAQf,QAAR","names":["composeUR","payload","type","composeDigest","digest","composeSequencing","index","total","composeHeadersToFragments","fragments","length","map","f","utils_1","encodeUR","fragmentCapacity","cborPayload","miniCbor_1","bc32Payload","bc_bech32_1","Buffer","from","toString","bc32Digest","match","RegExp","Error","str","toUpperCase","exports"],"sourceRoot":"","sources":["../src/encodeUR.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}